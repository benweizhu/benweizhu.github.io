<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[NO END FOR LEARNING]]></title>
  <link href="http://benweizhu.github.io/atom.xml" rel="self"/>
  <link href="http://benweizhu.github.io/"/>
  <updated>2015-09-18T21:26:26+08:00</updated>
  <id>http://benweizhu.github.io/</id>
  <author>
    <name><![CDATA[ZHU Benwei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于运行Active Record数据迁移]]></title>
    <link href="http://benweizhu.github.io/blog/2015/09/10/active-record-migration/"/>
    <updated>2015-09-10T08:51:45+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/09/10/active-record-migration</id>
    <content type="html"><![CDATA[<p>Active Record数据库迁移是 Active Record提供的一个功能，按照时间顺序管理数据库模式。使用迁移，无需编写 SQL，使用简单的Ruby DSL就能修改数据表，对数据库的操作和所用的数据库种类无关。</p>

<p>你可以把每个迁移看做数据库的一个修订版本。数据库中一开始什么也没有，各个迁移会添加或删除数据表、字段或记录。Active Record知道如何按照时间线更新数据库，不管数据库现在的模式如何，都能更新到最新结构。同时，Active Record还会更新db/schema.rb文件，匹配最新的数据库结构。</p>

<h2>db:migrate</h2>

<p>Rails提供了很多Rake任务，用来执行指定的迁移。</p>

<p>其中最常使用的是rake db:migrate，执行还没执行的迁移中的change或up方法。如果没有未运行的迁移，直接退出。rake db:migrate按照迁移文件名中时间戳顺序执行迁移。</p>

<p>注意，执行db:migrate时还会执行db:schema:dump，更新db/schema.rb文件，匹配数据库的结构。</p>

<h2>db:migrate VERSION</h2>

<p>如果指定了版本，Active Record会运行该版本之前的所有迁移。版本就是迁移文件名前的数字部分。例如，要运行 20080906120000 这个迁移，可以执行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">db</span><span class="p">:</span><span class="n">migrate</span> <span class="no">VERSION</span><span class="o">=</span><span class="mi">20080906120000</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果20080906120000比当前的版本高，上面的命令就会执行所有20080906120000之前（包括 20080906120000）的迁移中的change或up方法，但不会运行20080906120000之后的迁移。如果回滚迁移，则会执行 20080906120000之前（不包括20080906120000）的迁移中的down方法。</p>

<h2>db:rollback</h2>

<p>还有一个常用的操作时回滚到之前的迁移。例如，迁移代码写错了，想纠正。我们无须查找迁移的版本号，直接执行下面的命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">db</span><span class="p">:</span><span class="n">rollback</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个命令会回滚上一次迁移，撤销 change 方法中的操作，或者执行 down 方法。如果想撤销多个迁移，可以使用 STEP 参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">db</span><span class="p">:</span><span class="n">rollback</span> <span class="no">STEP</span><span class="o">=</span><span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个命令会撤销前三次迁移。</p>

<h2>db:redo</h2>

<p>db:migrate:redo 命令可以回滚上一次迁移，然后再次执行迁移。和 db:rollback 一样，如果想重做多次迁移，可以使用 STEP 参数。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">db</span><span class="p">:</span><span class="ss">migrate</span><span class="p">:</span><span class="k">redo</span> <span class="no">STEP</span><span class="o">=</span><span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些 Rake 任务的作用和 db:migrate 一样，只是用起来更方便，因为无需查找特定的迁移版本号。</p>

<h2>db:migrate:up和db:migrate:down</h2>

<p>如果想执行指定迁移，或者撤销指定迁移，可以使用db:migrate:up和db:migrate:down任务，指定相应的版本号，就会根据需求调用change、up或down方法。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">db</span><span class="p">:</span><span class="ss">migrate</span><span class="p">:</span><span class="n">up</span> <span class="no">VERSION</span><span class="o">=</span><span class="mi">20080906120000</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个命令会执行20080906120000迁移中的change方法或up方法。db:migrate:up 首先会检测指定的迁移是否已经运行，如果Active Record任务已经执行，就不会做任何操作。</p>

<h2>修改现有的迁移</h2>

<p>有时编写的迁移中可能有错误，如果已经运行了迁移，不能直接编辑迁移文件再运行迁移。Rails 认为这个迁移已经运行，所以执行 rake db:migrate 任务时什么也不会做。这种情况必须先回滚迁移（例如，执行 rake db:rollback 任务），编辑迁移文件后再执行 rake db:migrate 任务执行改正后的版本。</p>

<p>一般来说，直接修改现有的迁移不是个好主意。这么做会为你以及你的同事带来额外的工作量，如果这个迁移已经在生产服务器上运行过，还可能带来不必要的麻烦。你应该编写一个新的迁移，做所需的改动。编辑新生成还未纳入版本控制的迁移（或者更宽泛地说，还没有出现在开发设备之外），相对来说是安全的。</p>

<h2>在不同的环境中运行迁移</h2>

<p>默认情况下，rake db:migrate 任务在 development 环境中执行。要在其他环境中运行迁移，执行命令时可以使用环境变量 RAILS_ENV 指定环境。例如，要在 test 环境中运行迁移，可以执行下面的命令：</p>

<p>$ rake db:migrate RAILS_ENV=test</p>

<p>参考资料：   <br/>
1.<a href="http://guides.ruby-china.org/active_record_migrations.html">http://guides.ruby-china.org/active_record_migrations.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP 深入了解（一）还给业务逻辑代码一个干净的世界]]></title>
    <link href="http://benweizhu.github.io/blog/2015/09/06/deep-into-spring-aop-1/"/>
    <updated>2015-09-06T10:49:31+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/09/06/deep-into-spring-aop-1</id>
    <content type="html"><![CDATA[<h2>本篇博客系列的目的：</h2>

<p>之前一直想要实现一个日志类库：<a href="https://github.com/benweizhu/LoggerUtil">https://github.com/benweizhu/LoggerUtil</a></p>

<p>用来记录某个方法在调用前，调用后，抛出异常后的一些信息，比如方法名，参数，返回值。还希望可以指定记录的格式以及日志的级别（INFO，DEBUG等）。最关键的是，这个日志类库，必须有通用性和不可以有侵入性，这就导致它必定通过AOP来实现。</p>

<p>于是，为了做到这一点，现在我们就来深入的学习一次AOP：</p>

<h2>为什么要AOP</h2>

<p>编程语言最终极的目标就是能以更自然、更灵活的语言的方式模拟世界，从原始机器语言到过程语言再到面向对象的语言（OOP）。AOP提供了与OOP不同的另外一种方式来思考软件架构。OOP的模块单元是“类”，而AOP的模块单元“面”（Aspect）。</p>

<h4>那么问题来了，什么是“面”？以及什么“面向切面编程”？</h4>

<p>AOP被翻译成“面向方面编程”，“面向切面编程”，所以这里我更倾向于将“面”理解为“切面”（Aspect）。</p>

<p>从字面上理解，“切面”来自几何学，在立体几何中，切面是指用一个平面去截一个几何体（包括圆柱，圆锥，球，棱柱，棱锥、长方体，正方体等等），得到的平面图形。</p>

<p>那什么是“面向切面编程”？就是在该切面上加入一些逻辑操作（可以简单理解为“面向切面的操作”）。举个最常见的例子：</p>

<p>扑克牌的切牌，你可以将“广告牌”切入在任何你想要切入（或插入）的位置（你可以对扑克牌的任何一个切面做切牌操作）。插入的位置就是切面，插入的广告牌就是逻辑操作。</p>

<p>又或者是“斗地主”中，第一把不知道谁是地主，于是将一张牌反插入到牌的中间。本来应该按照顺序发牌，并不能知道谁是地主，但是因为你在某个位置插入了一个特殊操作（将一张牌反插入），因为多了一个逻辑，所以可以知道谁是地主。（或者将广告牌插入中间，也可以知道谁是地主）</p>

<p>这是“面向切面的编程”的最基础理解。</p>

<h3>也许你还是不能理解面向切面编程，最重要是你并不知道为什么需要它，即何时需要它？</h3>

<p>在OO的世界里，我们操作的是对象，创建一个对象并使用对象的属性和方法，而对象有抽象和继承的特性，因此，我们会利用抽象和继承的特性来消除重复的代码。</p>

<p>我们知道，编程语言是从原始机器语言到过程语言再到面向对象的语言，但是即便是OO的世界，我们也逃离不了面向过程的编程方式，代码的每一步操作一定是有顺序的，因为机器解释代码也是按顺序执行的。</p>

<p>代码按照顺序执行无可厚非，遇到重复的代码，我们利用抽象的方式，将重复的部分抽离成一个独立模块（方法或者类），由所有需要的地方重用即可。</p>

<p>但有一种顺序代码，它重复使用在不同的固定位置，它与业务代码无关，通过OO的常用办法并不能消除这种模式的重复，比如：事务管理，性能监控（和控制）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addUser</span><span class="o">(){</span>
</span><span class='line'>  <span class="n">transactionManager</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>
</span><span class='line'>  <span class="o">..</span>
</span><span class='line'>  <span class="n">transactionManager</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们知道这些重复性的代码逻辑，是可以非常轻松的独立出来，比如，beginTransaction和commit方法，但，我们无法通过抽象的方式来消除这种重复的调用，因为它和业务代码具有关联性，它依附在业务代码的顺序流程中。</p>

<p>有人说，可以采用模板方法（设计模式中的一种模式），这样可以消除重复，但也导致所有使用模板方法的类，都要重写模板中的其中一步（某个方法）来实现业务逻辑，重写方法是不能改变方法的名字。这样就给代码的自描述性带来了困难，得不偿失。</p>

<p>好在AOP希望做得到的就是，将这些分散在各个不同业务逻辑代码中的相同代码，通过切入的方式，将这块具有顺序性关联的逻辑抽离到独立模块，而在逻辑代码中将看不到之前重复的逻辑。</p>

<p>从而，还给业务逻辑代码一个干净的世界。这就是AOP给我们带来的好处。</p>

<p>参考资料：  <br/>
1.Spring 3.0就是这么简单  <br/>
2.<a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/aop.html">http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/aop.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用Postgres全文搜索特性（一）]]></title>
    <link href="http://benweizhu.github.io/blog/2015/08/09/postgres-full-text-search-1/"/>
    <updated>2015-08-09T08:24:23+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/08/09/postgres-full-text-search-1</id>
    <content type="html"><![CDATA[<h2>基本概念</h2>

<p>全文搜索提供了一种能力来鉴别的自然语言文档是否满足某个查询语句，并根据与查询语句的相关性来对查询结果排序。最常见的查询就是找到所有包含查询术语（term）的文档，并根据他们的相似性进行排序。</p>

<p>文字查询已经在数据库中存在多年。PostgreSQL有~，~*，LIKE和ILIKE这样的对应文字数据类型的操作符，但它们缺少现代信息系统需要的必要属性：</p>

<p>1.没有语言特性的支持，比如，英语中的单数和复数，用正则表达式是做不到识别复数单词的。<br/>
2.没有查询结果的相似性的排序。 <br/>
3.因为没有索引支持，所以会比较慢</p>

<p>全文搜索允许对文档进行预处理，比允许建立索引来提供搜索速度。预处理一般包括：</p>

<p>1.将文档解析为符号。这对于解析不同类型的符号非常有用。比如，数字，单词，复杂单词，email，这样它们就可以用不同的方式被处理。原则上，符号类型取决于文档，但是大部分情况，可以使用预定义的类型就足够了。Postgres提供了一个标准的解析器，但也可以建立自定义的解析器。</p>

<p>2.将符号转化为分词。一个分词（词位，单词单位）是一个字符串，跟符号相似，但是它被正常化，这样就可以匹配同一个单词的不同形式，比如，正常化允许将大写字母转换为小写，更常见的是英语单词的前缀和后缀（复数单词），这就允许搜索同一个单词的不同形式，而不需要输入该单词的全部可能变形式。（话句话说，符号是文档文本的直接片段，而分词是可以用来索引和搜索的有用单词）。而Postgres实现这种方式的办法就是利用词典，可以提供不同标准的词典，或者自定义的词典来满足不同的需要。</p>

<p>3.Storing preprocessed documents optimized for searching. For example, each document can be represented as a sorted array of normalized lexemes. Along with the lexemes it is often desirable to store positional information to use for proximity ranking, so that a document that contains a more &ldquo;dense&rdquo; region of query words is assigned a higher rank than one with scattered query words.(这段没看明白)</p>

<h2>文档</h2>

<p>上面提到一个很重要的概念，叫做文档（Document）。那么，它的含义是什么？</p>

<p>在PostgresSQL的搜索中，文档可以是数据库表中某一行的某一个文字字段（textual field），或者是多个这样的字段的组合，也许他们存储在不同表中，又或者是动态获取到的结果。话句话说，文档是由不同的部分组成，可能并不会作为一个整体存在某一个位置。比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="n">title</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span>  <span class="n">author</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span>  <span class="n">abstract</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">body</span> <span class="k">AS</span> <span class="n">document</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">messages</span>
</span><span class='line'><span class="k">WHERE</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">SELECT</span> <span class="n">m</span><span class="p">.</span><span class="n">title</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">author</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">abstract</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">d</span><span class="p">.</span><span class="n">body</span> <span class="k">AS</span> <span class="n">document</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">messages</span> <span class="n">m</span><span class="p">,</span> <span class="n">docs</span> <span class="n">d</span>
</span><span class='line'><span class="k">WHERE</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">did</span> <span class="k">AND</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> 
</span></code></pre></td></tr></table></div></figure>


<p>title，author，abstract作为了文档，它们是message的不同字段。</p>

<p>还有一种可能，文档以简单文本的方式存储在文件系统中，这样的情况下，数据库中可以存放全文的索引来执行搜索，并使用一些独立的标识符来从文件系统中获取文档。</p>

<h2>TSVECTOR（分词向量）</h2>

<p>以文本搜索为目的，每个文档必须缩减为预处理的tsvector（某种向量）形式，搜索和排名都是在这个可以代表文档的tsvector上执行，文档只是在需要用户需要使用时才去获取，因此，我们常常将tsvector作为一种文档，当然它只是全文文档的一种压缩形式。</p>

<p>PostgreSQL全文搜索是基于匹配操作符@@实现，当一个tsvector（document）匹配一个tsquery（query）时，返回true。至于哪个写在前面，哪个写在后面不重要：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="s1">&#39;a fat cat sat on a mat and ate a fat rat&#39;</span><span class="p">::</span><span class="n">tsvector</span> <span class="o">@@</span> <span class="s1">&#39;cat &amp; rat&#39;</span><span class="p">::</span><span class="n">tsquery</span><span class="p">;</span>
</span><span class='line'> <span class="o">?</span><span class="k">column</span><span class="o">?</span>
</span><span class='line'><span class="c1">----------</span>
</span><span class='line'> <span class="n">t</span>
</span><span class='line'>
</span><span class='line'><span class="k">SELECT</span> <span class="s1">&#39;fat &amp; cow&#39;</span><span class="p">::</span><span class="n">tsquery</span> <span class="o">@@</span> <span class="s1">&#39;a fat cat sat on a mat and ate a fat rat&#39;</span><span class="p">::</span><span class="n">tsvector</span><span class="p">;</span>
</span><span class='line'> <span class="o">?</span><span class="k">column</span><span class="o">?</span>
</span><span class='line'><span class="c1">----------</span>
</span><span class='line'> <span class="n">f</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上面的例子中，一个tsquery不是单纯的文本，tsvector也是一样。一个tsquery包含搜索术语（term），它们是已经做过正常化的分词，并且可能通过AND，OR和NOT操作将多个术语结合。函数to_tsquery和plainto_tsquery可以帮助将用户写的文本转化为适当的tsquery。简单来说，to_tsvector是用来解析和正常化一个文档字符串的。所以，在实际应用中，一个文本搜索匹配应该长如下这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;fat cats ate fat rats&#39;</span><span class="p">)</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;fat &amp; rat&#39;</span><span class="p">);</span>
</span><span class='line'> <span class="o">?</span><span class="k">column</span><span class="o">?</span>
</span><span class='line'><span class="c1">----------</span>
</span><span class='line'> <span class="n">t</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，如果写成如下方式将不会成功：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="s1">&#39;fat cats ate fat rats&#39;</span><span class="p">::</span><span class="n">tsvector</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;fat &amp; rat&#39;</span><span class="p">);</span>
</span><span class='line'> <span class="o">?</span><span class="k">column</span><span class="o">?</span>
</span><span class='line'><span class="c1">----------</span>
</span><span class='line'> <span class="n">f</span>
</span></code></pre></td></tr></table></div></figure>


<p>@@操作符也支持文本输入，简单情况下，允许跳过具体的tsvector或者tsquery的转换。使用如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">tsvector</span> <span class="o">@@</span> <span class="n">tsquery</span>
</span><span class='line'><span class="n">tsquery</span>  <span class="o">@@</span> <span class="n">tsvector</span>
</span><span class='line'><span class="nb">text</span> <span class="o">@@</span> <span class="n">tsquery</span>
</span><span class='line'><span class="nb">text</span> <span class="o">@@</span> <span class="nb">text</span>
</span></code></pre></td></tr></table></div></figure>


<h2>如何在数据库表中进行搜索，并使用索引呢？</h2>

<p>我们是可以再没有索引的情况下做全文搜索的，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="n">title</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">pgweb</span>
</span><span class='line'><span class="k">WHERE</span> <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="s1">&#39;friend&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建索引</h3>

<p>我们可以创建GIN索引来提供文本搜索的速度：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">pgweb_idx</span> <span class="k">ON</span> <span class="n">pgweb</span> <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里使用两个参数的to_tsvector方法。只有文本搜索指定了一个配置名字才能使用在表达式索引中。这是因为索引内容必须不被default_text_search_config所影响。如果它们被影响了，索引内容有可能不一致，因为不同的条目（entries）可以包含有不同配置生成的tsvector，所以没有办法猜测谁是谁。所以也就没办法正确的删除和还原这样是索引。</p>

<p>因为上面使用了两个参数版本的to_tsvector，只有也使用了两参数版本to_tsvector并且配置相同的查询语句才能使用。也就说，WHERE to_tsvector(&lsquo;english&rsquo;, body) @@ &lsquo;a &amp; b&#8217;可以使用索引，WHERE to_tsvector(body) @@ &#8216;a &amp; b&#8217;就不行。</p>

<p>索引可以建立在联合的字段中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">pgweb_idx</span> <span class="k">ON</span> <span class="n">pgweb</span> <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="n">title</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">body</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h3>在单独的字段创建向量</h3>

<p>另外一种办法就是创建一个单独的tsvector字段来保存to_tsvector的输出，本例中，coalesce用来保证即便有一个字段是null，仍然会生成索引：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">pgweb</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">textsearchable_index_col</span> <span class="n">tsvector</span><span class="p">;</span>
</span><span class='line'><span class="k">UPDATE</span> <span class="n">pgweb</span> <span class="k">SET</span> <span class="n">textsearchable_index_col</span> <span class="o">=</span>
</span><span class='line'>     <span class="n">to_tsvector</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建一个GIN索引来加快搜索：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">textsearch_idx</span> <span class="k">ON</span> <span class="n">pgweb</span> <span class="k">USING</span> <span class="n">gin</span><span class="p">(</span><span class="n">textsearchable_index_col</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在可以来执行一个快速的全文搜索：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="n">title</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">pgweb</span>
</span><span class='line'><span class="k">WHERE</span> <span class="n">textsearchable_index_col</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">&#39;create &amp; table&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">last_mod_date</span> <span class="k">DESC</span>
</span><span class='line'><span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当使用独立字段来存储tsvector的结果时，非常有必要创建一个触发器（trigger）来保证tsvector的状态，当title或者body发生改变。</p>

<p>独立列的方式比表达式索引方式好的其中一点是当使用索引查询时，不用在查询语句中指定文本查询的配置。正如上面的例子中，查询语句依赖于default_text_search_config。另外一个优点是，查询更快速，因为它不需要重新执行to_tsvector来验证索引的匹配（特别是使用GiST的时候）。唯一的不同时，这种方式需要占据存储空间。</p>

<p>参考自：<a href="http://www.postgresql.org/docs/9.2/static/textsearch-intro.html">http://www.postgresql.org/docs/9.2/static/textsearch-intro.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS后代选择器以及选择器特殊性]]></title>
    <link href="http://benweizhu.github.io/blog/2015/08/01/css-selector-basic/"/>
    <updated>2015-08-01T17:46:56+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/08/01/css-selector-basic</id>
    <content type="html"><![CDATA[<h3>常用的重要选择器规则：</h3>

<p>element,element div,p   选择所有 div 元素和所有 p 元素。  <br/>
element element div p   后代选择器：选择 div 元素内部的所有 p 元素。 <br/>
element>element div>p   子选择器：选择父元素为 div 元素的所有 p 元素。  <br/>
element+element div+p   第一个子元素选择器：选择紧接在 div 元素之后的所有 p 元素。</p>

<h3>后代选择器</h3>

<p>后代选择器（descendant selector）又称为包含选择器。后代选择器可以选择作为某元素后代的元素。</p>

<p>我们可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。
举例来说，如果你希望只对 h1 元素中的 em 元素应用样式，可以这样写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">h1</span> <span class="nt">em</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span><span class="nb">red</span><span class="p">;}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个规则会把作为 h1 元素后代的 em 元素的文本变为 红色。其他 em 文本（如段落或块引用中的 em）则不会被这个规则选中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;h1&gt;</span>This is a <span class="nt">&lt;em&gt;</span>important<span class="nt">&lt;/em&gt;</span> heading<span class="nt">&lt;/h1&gt;</span>
</span><span class='line'><span class="nt">&lt;p&gt;</span>This is a <span class="nt">&lt;em&gt;</span>important<span class="nt">&lt;/em&gt;</span> paragraph.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。选择器之间的空格是一种结合符（combinator）。每个空格结合符可以解释为“&hellip; 在 &hellip; 找到”、“&hellip; 作为 &hellip; 的一部分”、“&hellip; 作为 &hellip; 的后代”，但是要求必须从右向左读选择器。
因此，h1 em 选择器可以解释为 “作为 h1 元素后代的任何 em 元素”。如果要从左向右读选择器，可以换成以下说法：“包含 em 的所有 h1 会把以下样式应用到该 em”。</p>

<p>关于后代选择器有一个常被忽略的方面，即两个元素之间的层次间隔可以是无限的。例如，如果写作ul em，这个语法就会选择从u1元素继承的所有em元素，而无论em的嵌套层次有多深。</p>

<h3>子选择器</h3>

<p>某些情况下，可能并不想选择一个任意的后代元素，而是希望缩小范围，只选择另一个元素的子元素（不是所有后代元素）。可以使用子结合符，即大于号(>)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">h1</span> <span class="o">&gt;</span> <span class="nt">strong</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>特殊性</h3>

<p>如果有多个选择器都满足同一个元素，即冲突了，怎么知道哪一个规则更强？</p>

<p>答案在于每个选择器的特殊性。对于每个规则，用户代理会计算选择器的特殊性，并将这个特殊性附加在规则中的各个声明。如果一个元素有两个或者多个冲突的属性声明，那么有最高特殊性的声明就会胜出。</p>

<p>选择器的特殊性由选择器本身的组件确定。特殊性表述为4个部分，0,0,0,0</p>

<p>1.对于选择器中给定的各个ID属性，加 0,1,0,0
2.对于选择器中给定的各个类元素，属性选择器或伪类，加 0,0,1,0
3.对于选择器中给定的各个元素和伪元素，加0,0,0,1
4.结合符和通配选择器对特殊性没有任何贡献</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">h1</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">1</span>
</span><span class='line'><span class="nt">p</span> <span class="nt">em</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">purple</span><span class="p">;}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">2</span>
</span><span class='line'><span class="nc">.grape</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">purple</span><span class="p">}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">1</span><span class="o">,</span><span class="nt">0</span>
</span><span class='line'><span class="o">*</span><span class="nc">.bright</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">yellow</span><span class="p">}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">1</span><span class="o">,</span><span class="nt">0</span>
</span><span class='line'><span class="nt">p</span><span class="nc">.bright</span> <span class="nt">em</span><span class="nc">.dark</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">maroon</span><span class="p">}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="nt">2</span><span class="o">,</span><span class="nt">2</span>
</span><span class='line'><span class="nt">div</span><span class="nf">#sidebar</span> <span class="o">*[</span><span class="nt">href</span><span class="o">]</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="nb">silver</span><span class="p">}</span> <span class="nt">0</span><span class="o">,</span><span class="nt">1</span><span class="o">,</span><span class="nt">1</span><span class="o">,</span><span class="nt">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>第五条规则强于第二条</p>

<p>0011 > 0001
0101 > 0017</p>

<p>内联样式的特殊性
我们已经见过以0开头的特殊性，所以你可能会奇怪为什么会有这些特殊性。一般地，第一个0是为内联样式声明保留的，它比所有其他声明的特殊性都高，内联样式的特殊性是1,0,0,0</p>

<h3>!important 重要性规则</h3>

<p>有时某个声明可能非常重要，超过了所有其他声明。CSS2.1称之为重要声明，并允许在这些声明的结束分号之前插入!important来标识。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">p</span><span class="nc">.dark</span> <span class="p">{</span><span class="k">color</span><span class="o">:</span> <span class="m">#333</span> <span class="cp">!important</span><span class="p">;</span> <span class="k">background</span><span class="o">:</span> <span class="nb">white</span><span class="p">;}</span>
</span></code></pre></td></tr></table></div></figure>


<p>必须正确地放置!important，否则声明将无效，它应该总是放在声明的最后，即分号之前。如果一个属性的值包含多个关键字，则必须放在最后一个关键词的后面，比如font：sss,sss !important;</p>

<p>标志位!important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。实际上，所有!important声明会分组在一起，重要声明的特殊性冲突会在重要声明内部解决，而不会与非重要声明相混肴。类似的，非重要声明也归为一组，使用特殊性来解决冲突。如果一个重要声明和一个非重要声明冲突，胜出的总是重要声明。</p>

<p>1.《css权威指南》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解设计RESTful API - 资源、表述和HTTP协议语义]]></title>
    <link href="http://benweizhu.github.io/blog/2015/07/25/restful-web-api-part-1/"/>
    <updated>2015-07-25T20:39:45+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/07/25/restful-web-api-part-1</id>
    <content type="html"><![CDATA[<h3>什么是资源？什么是表述？</h3>

<p>就本质而言，任何足够重要并被引用的事物都可以是资源。如果你的用户“想要建立指向它的超文本链接，指出或者反对关于它的断言，获取或者缓存它的表述，共另外的表述引用它的全部或者部分，给它增加注释信息，或者对它执行某些操作”，（源自《万维网的架构》），你都应该将它定义为资源。</p>

<p>每个资源必须拥有URL，在web上，我们使用URL来为每个资源提供一个全球唯一的地址，将一个事物赋以URL，它就会成为一个资源。</p>

<p>石榴可以是一个资源，但是你不可能通过互联网传输它，数据库中的一条记录可以是一个资源，并且可以通过互联网传输。</p>

<p>当客户端对一个资源发起一个Get请求的时候，服务器会以一种有效的方式提供一个采集了资源信息的文档作为回应。这种资源信息的文档就是一种表述，一种以机器可读的方式对资源当前的状态进行说明。</p>

<h3>资源有多重表述</h3>

<p>一个资源可以有多种表述。比如，有的资源可以有整体概括性的表述，也可以有面面俱到的详细表述，又或者可能以JSON格式或者XML格式来表述同一个资源。</p>

<h3>约束 - HTTP协议语义</h3>

<p>尽管任何事物都可以成为一个资源，但是客户端并不能随心所欲地对资源进行任意的操作。所能进行的操作是有规定的。在一个RESTful系统里，客户端和服务器端只能通过相互发送遵循预定义协议的消息来进行交互。在Web API的世界里，该协议就是HTTP。</p>

<p>在设计Web API时，严格遵守HTTP协议语义是设计好的API的重要基础。</p>

<h4>GET请求</h4>

<p>客户端通过发送Get请求来获取某个URL所标示的资源的表述。Get被定义为安全的HTTP方法。它仅仅是对信息的一次请求。向服务器发送一条Get请求对资源的影响应该和没有发送一样。</p>

<h4>DELETE请求</h4>

<p>发送DELETE请求，客户端希望服务器将资源销毁，并且以后再也不会跳到它。当Get请求再次访问一个已经销毁的资源，服务器应该返回错误响应码，比如404（Not Found）。Delete不是一个安全的方法，它会改变资源的状态，但是DELETE方法有另外一个很重要的属性，就是幂等性。当你发送一个DELETE请求后，资源就永久性的消失了，即便之后，再次发送相同的DELETE请求，也许你会收到404的错误码，但是第二次发送后和第一次发送后，资源的状态是一致的，仍然不存在。</p>

<p>幂等性是一个很重要的特性，因为互联网的不稳定性，假设发送的一个Delete请求，因为连接超时，你并没有收到响应，所以你无法知道发送的Delete请求是否顺利完成，这时你也许会发送第二次Delete请求。幂等性保证了执行两次Delete请求并不会比执行一次Delete请求给资源带来更多的影响。</p>

<h4>POST-to-Append请求</h4>

<p>为什么是Post-to-Append而不是Post呢？因为Post方法可以做两件事情，第一件事情就是Post-to-Append，第二件事情叫做overloaded post。我们先看POST-to-Append，向某个资源发送一条Post请求用以在该资源的下一级中创建新的资源，当客户端发送一个POST-to-Append请求时，它会在请求的实体消息体中添加所希望创建的资源的表述信息并发给服务器。Post方法既不安全也不幂等，如果发送多次Post请求，就会创建多个资源。</p>

<h4>PUT请求</h4>

<p>Put请求用于修改资源的状态。客户端一般会通过Get请求获取表述，然后对其进行修改，最后再将修改后的资源表述作为PUT请求的负载数据发送回去。PUT请求也是幂等的，无论发送多少次PUT请求，结果都和第一次发送PUT请求一样。</p>

<hr />

<p>以上4种请求，我们最常见也是使用最频繁的请求。接下来要介绍的请求，虽然见的不多，但是当你了解后，你会觉得它非常有用。</p>

<h4>PATCH请求</h4>

<p>表述的信息量可能非常大。虽然，我们可以使用PUT请求来修改资源，但是如果只想修改资源状态的部分，或者说很少一部分，才PUT就会造成极大的资源浪费，这对于移动应用所使用的Web API设计是非常重要的。和将完整信息发送过去的PUT方法不同，PATCH方法将一个“diff”的表述放在请求的负载数据中发送给服务器。</p>

<h4>HEAD请求</h4>

<p>Head方法是和Get方法一样的安全方法。服务器应该和处理Get方法一样除了Head方法，但是Head方法不需要发送实体消息，只需要发送HTTP状态码和报头。</p>

<h4>OPTIONS请求</h4>

<p>OPTIONS是HTTP的原生探索机制。一个OPTIONS请求的返回结果包含一个HTTP Allow报头，这个报头展示了这个资源所支持的所有HTTP方法。</p>

<h4>肮脏的Overloaded POST请求</h4>

<p>POST不仅仅被用于创建新的资源，在用浏览器上网的时候，POST也被用于传输任何形式的变化，它将PUT、DELETE、PATCH、LINK和UNLINK所有的方法混合成一个方法。</p>

<p>比如，在页面有一个表单对用户的基本信息进行修改，它是一个POST请求，但是从语义上，它更像是一个PUT，但这完全是合法的，任何数据作为POST请求的一部分发出去，不论是出于什么目的，这都是合法的。这导致POST请求没有任何语义。由于重载后的POST请求可以用来完成任何事情，所以这种POST方法既不安全也不幂等。</p>

<hr />

<p><strong>好的API不应该依靠文档来维护它的使用方式，就好像是优秀的代码，不需要注释来考诉你它是干什么，合理的协议语义的使用会帮助API实现基本的自我描述，虽然这还远远不够，但它最起码是互联网上大家都遵守的约束。</strong></p>

<p>参考资料： <br/>
1. RESTful Web AIPs</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Linux就是这个范儿》读书笔记（一） - 理解Linux用户和用户组]]></title>
    <link href="http://benweizhu.github.io/blog/2015/07/13/linux-you-dont-understand-all-these-years/"/>
    <updated>2015-07-13T17:03:21+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/07/13/linux-you-dont-understand-all-these-years</id>
    <content type="html"><![CDATA[<h3>理解什么是多用户多任务分时操作系统</h3>

<p>“将大型电脑的珍贵时间资源适当的分配到所有使用者身上，让所有使用者都有独占整部机器的感觉，这是当时计算机先驱提出的分时系统的概念。依据这个想法，通用电气、麻省理工学院和贝尔实验室联手启动Multics项目，这是在当时看着最靠谱的分时系统概念。但是由于太“靠谱”了（真正的多用户多任务分时操作系统），在当时的技术条件下去完成它实在是吃力，所以最终的命运很悲惨。但是有两个游戏爱好者，Multics的成员Ken和Dennis为了能够有电脑玩游戏，决定自己给一台闲置的电脑写个操作系统，于是 — 一个实用的多用户多任务分时操作系统就诞生了。” &mdash;-《Linux就是这个范》</p>

<p>我们所熟知的Windows、Linux、Mac OS X等都是多用户多任务分时操作系统。最显著的特点就是可以让多个人使用同一台电脑而不能互相窥探对方的秘密（多用户）。当你使用电脑时，可以边放音乐，边聊QQ，边浏览网页（多任务）。分时就像之前的定义那样，将电脑的时间资源适当的分配给所有的使用者身上，如果将使用者抽象，它不仅仅代表“人”，可以代表任何使用电脑时间资源的任务，在这样的理解下，分时就成为了多用户和多任务的基础。</p>

<h3>澡堂文化 - 多用户</h3>

<p>Linux中的用户管理是管理用户的等级和对文件的访问权限。</p>

<p>用户等级只有两个root和非root用户。root用户拥有至高无上的权利，用户名就是root，相当于Windows中的Administrator，但幸运的是root用户只有一个。root用户通过文件严格控制着非root用户的访问权限。</p>

<p>在《Linux就是这个范》这本书中，作者将这种管理方式形象的描述为“澡堂子模型”。root用户就是澡堂子的服务生，每个来澡堂子的人，服务生都会给分配一个号码牌，就像root用户给非root用户分配账号。每个号码牌上都有一个钥匙，可以打开对应的柜子。</p>

<p>而每个非root用户一般会拥有自己的文件目录（某些不会，它们可能是执行特殊任务的用户，不需要自己的文件目录），目录路径一般是/home/[username]，这就是，每个非root用户的目录就对应着每个来澡堂中的柜子。</p>

<h3>用户权限（不同的职业）</h3>

<p>在使用Linux的时候，经常会遇到无法对文件读写，或者执行，因为当前登录账号的权限不够。因此，会给予一种错觉，那就是账号分为不同的权限级别，另一个账号可以访问，因为它比当前登录账号权限更高。</p>

<p>但这其实是一种错误的理解，前面已经提到，Linux中用户等级只有两个，root和非root，除了root用户拥有至高无上的权利外，其他用户都是一样的渣渣。</p>

<p>导致这种错觉的原因，是因为还有一个用户组的概念（职业）。</p>

<p>一个用户可以属于多个用户组，就像一个人可以身兼多职一样。由于用户组能够在更高的层面来抽象用户所能够访问文件的数量，因此结合不同的用户组，就能给每个用户构建出独一无二的文件访问列表。</p>

<h3>用户和用户组管理</h3>

<p>用户和用户组信息分别存放在etc/passwd和etc/group中，Linux系统为用户和用户组文件的CRUD操作提供了一些基本命令，这些命令的作用就是对etc/passwd和etc/group两个文件的文件内容进行增删改，然后，外加一个etc/shadow文件来管理密码，就实现了对用户和用户组的管理。</p>

<p>关于什么样的命令来管理用户和用户组，这里不做更多介绍，可以参考其他资料。</p>

<h3>神秘的sudo-假借身份</h3>

<p>安装软件是使用Linux操作系统最常见的操作。但Linux中的用户除了root就是普通用户，而普通用户的权限非常低，就连向系统中安装软件的权利都没有。很多时候系统管理员为了能够让普通用户具备一点root的特权，就赋给普通用户一个称为sudo的特权。</p>

<p>普通用户一旦拥有sudo的特权，几乎就可以胡作非为，但需要付出一点代价，需要在将要执行的命令前加上sudo作为前缀，同时被系统提示输入当前用户的密码。这样做的好处是防止不怀好意的进行不安全的操作。因为你不是root用户，所以如果有恶意软件要使用sudo进行操作，此时就会被需要输入密码，这种无缘无故需要输入密码的行为一定会被你发现。</p>

<p>不同的Linux发行版本，可能一般的非root用户不会立即拥有sudo特权。所以这时就需要自己去给某个用户赋予sudo特权，方法是修改/etc/sudoers这个文件。至于文件里的内容长什么样，这里也不过多介绍，可以参考其他资料。</p>

<h3>每次都要sudo，好麻烦，干脆su</h3>

<p>要使用sudo特权，必须每次在命令前加上sudo，这样对管理Linux系统不太方便。su命令可以临时切换用户，默认是切换到root用户。</p>

<p>切换用户需要输入目标用户的密码，切换到root用户就需要root用户的密码。</p>

<h3>我是谁和我到底是谁</h3>

<p>要知道当前用户是谁，有三条命令可以用，whoami，who am i和who。第一个命令和后两条命令有本质区别，这里要引入实际用户（UID）和有效用户（EUID）的概念。</p>

<p>实际用户就是指用户登录时所使用的用户，整个登录会话中，实际用户不会改变；有效用户是指当前执行操作的用户，该用户可以通过su切换，决定了权限的高低。</p>

<p>whoami查看的是有效用户，而who和who am i可以查看实际用户。</p>

<p>参考资料：  <br/>
1.Linux就是这个范儿</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Web Security 实战 (四) - 了解Security基础架构]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/17/spring-web-security-4/"/>
    <updated>2015-06-17T21:41:24+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/17/spring-web-security-4</id>
    <content type="html"><![CDATA[<p>在了解了Spring Security的基本使用之后，还是需要更深入的了解Spring Security的基础架构，核心组件等。</p>

<p>Spring Security是以自包含的角度来实现安全设计，所以使用Spring Security没有任何侵入性。因为Spring Security的目标是自己容器内管理， 所以不需要为你的Java运行环境进行什么特别的配置。</p>

<h2>核心组件</h2>

<h3>SecurityContextHolder, SecurityContext和Authentication对象</h3>

<p>SecurityContextHolder，就如该类的名字所描述的那样，它用来存放当前应用程序的当前安全上下文中的细节，当然也包括“当事人Principal”的细节。SecurityContextHolder将上下文信息存储在ThreadLocal当中，这意味着，安全环境在同一个线程执行的方法一直是有效的。这种情况下使用ThreadLocal是非常安全的，只要记得在处理完当前主体的请求以后，把这个线程清除就行了。当然，Spring Security自动帮你管理这一切了，你就不用担心什么了。</p>

<p>下面这段代码很清晰的说明了上面的实现策略：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ThreadLocalSecurityContextHolderStrategy</span> <span class="kd">implements</span> <span class="n">SecurityContextHolderStrategy</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">SecurityContext</span><span class="o">&gt;</span> <span class="n">contextHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">SecurityContext</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">SecurityContext</span> <span class="nf">getContext</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">SecurityContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">contextHolder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">ctx</span> <span class="o">=</span> <span class="n">createEmptyContext</span><span class="o">();</span>
</span><span class='line'>          <span class="n">contextHolder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">ctx</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你从SecurityContextHolder中拿到SecurityContext后，你就可以通过下面的这段代码取到“当事人”或者说用户的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Object</span> <span class="n">principal</span> <span class="o">=</span> <span class="n">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getPrincipal</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">principal</span> <span class="k">instanceof</span> <span class="n">UserDetails</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">((</span><span class="n">UserDetails</span><span class="o">)</span><span class="n">principal</span><span class="o">).</span><span class="na">getUsername</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">principal</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看完上面的代码，就要引入第二个关键组件Authentication：</p>

<p>Authentication是一个接口，代表着一种“认证”令牌，它里面存放着“当事人”的基本信息和是否认证的标志信息。框架在接受到认证请求时，会将新创建的Authentication对象会传递给AuthenticationManager.authenticate(Authentication)，由它来决定“认证”是否成功。</p>

<p>而一旦“认证”请求通过，Authentication通常都会存储在SecurityContext中，由SecurityContextHolder来管理。</p>

<p>除了主体，另一个Authentication提供的重要方法是getAuthorities()。 这个方法提供了GrantedAuthority对象数组。 毫无疑问，GrantedAuthority是赋予到主体的权限。这些权限通常使用角色表示，比如ROLE_ADMINISTRATOR或ROLE_HR_SUPERVISOR。</p>

<p>SecurityContextHolder，提供访问SecurityContext的方式。 <br/>
SecurityContext，保存Authentication信息，和请求对应的安全信息。  <br/>
Authentication，作为认证的令牌。  <br/>
GrantedAuthority，反应在应用程序范围内，赋予的权限。</p>

<h2>Spring Security的认证(Authentication)过程</h2>

<p>让我们考虑一种标准的验证场景，每个人都很熟悉的那种。 <br/>
一个用户想使用一个账号和密码进行登陆。     <br/>
系统（成功的）验证了密码对于这个用户名是正确的。 <br/>
这个用户对应的信息获取（他们的角色列表以及等等）。 <br/>
为用户建立一个安全环境。 <br/>
用户会执行一些操作，这些都是潜在被权限控制机制所保护的，通过对操作的授权，使用当前的安全环境信息。</p>

<p>前三个项目执行了验证过程，所以我们可以看一下Spring Security的作用。 <br/>
用户名和密码被获得，并进行比对，在一个UsernamePasswordAuthenticationToken的实例中（它是Authentication接口的一个实例，我们在之前已经见过了）。 <br/>
这个标志被发送给一个AuthenticationManager的实例进行校验。 <br/>
AuthenticationManager返回一个完全的Authentication实例，在成功校验后。 <br/>
安全环境被建立，通过调用SecurityContextHolder.getContext().setAuthentication(&hellip;)，传递到返回的验证对象中。</p>

<p>事实上，Spring Security并不介意你如何将Authentication对象放到SecurityContextHolder里。唯一关键的一点是 在AbstractSecurityInterceptor需要验证一个用户操作之前，SecurityContextHolder必须包含了一个表示了主体的Authentication。</p>

<p>待续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Web Security 实战 (三) - 改变用户认证方式和安全性]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/14/spring-web-security-3/"/>
    <updated>2015-06-14T17:19:38+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/14/spring-web-security-3</id>
    <content type="html"><![CDATA[<p>之前实现的表单提交方式来验证用户，实际上是不安全，http请求没有做任何的处理，表单内容以明文方式发送，在浏览器查看请求，得到结果就如下：</p>

<p>j_username:ben<br/>
j_password:ben <br/>
submit:Login</p>

<p>而且，用户名和密码保存在xml或者properties方式保存在服务器端，也是不合理的。</p>

<h2>Http Basic</h2>

<p>参考：<a href="http://blog.itpub.net/23071790/viewspace-709367/">http://blog.itpub.net/23071790/viewspace-709367/</a></p>

<p>“在HTTP协议进行通信的过程中，HTTP协议定义了基本认证过程以允许HTTP服务器对WEB浏览器进行用户身份证的方法，当一个客户端向HTTP服务 器进行数据请求时，如果客户端未被认证，则HTTP服务器将通过基本认证过程对客户端的用户名及密码进行验证，以决定用户是否合法。客户端在接收到HTTP服务器的身份认证要求后，会提示用户输入用户名及密码，然后将用户名及密码以BASE64加密，加密后的密文将附加于请求信息中， 如当用户名为anjuta，密码为：123456时，客户端将用户名和密码用“：”合并，并将合并后的字符串用BASE64加密为密文，并于每次请求数据 时，将密文附加于请求头（Request Header）中。HTTP服务器在每次收到请求包后，根据协议取得客户端附加的用户信息（BASE64加密的用户名和密码），解开请求包，对用户名及密码进行验证，如果用 户名及密码正确，则根据客户端请求，返回客户端所需要的数据;否则，返回错误代码或重新要求客户端提供用户名及密码。”</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;security:http&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/**&quot;</span> <span class="na">access=</span><span class="s">&quot;ROLE_USER&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:http-basic/&gt;</span>
</span><span class='line'><span class="nt">&lt;/security:http&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方式直接的表单要好点，但其实也不安全，用户名和密码可以通过BASE64反编码得到。</p>

<h2>使用数据库</h2>

<p>如果你想使用数据库作为身份认证的数据来源，非常简单，只需要配置一个DataSource即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;authentication-manager&gt;</span>
</span><span class='line'>  <span class="nt">&lt;authentication-provider&gt;</span>
</span><span class='line'>      <span class="nt">&lt;jdbc-user-service</span> <span class="na">data-source-ref=</span><span class="s">&quot;securityDataSource&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/authentication-provider&gt;</span>
</span><span class='line'><span class="nt">&lt;/authentication-manager&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的securityDataSource是Spring上下文种一个DataSource Bean，它指向一个含有Spring Security“标准用户数据库表”的数据库。</p>

<p>除了直接配置DataSource，你还可以配置一个Spring Security的JdbcDaoImpl的Bean，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;authentication-manager&gt;</span>
</span><span class='line'>  <span class="nt">&lt;authentication-provider</span> <span class="na">user-service-ref=</span><span class="s">&#39;myUserDetailsService&#39;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/authentication-manager&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;beans:bean</span> <span class="na">id=</span><span class="s">&quot;myUserDetailsService&quot;</span> <span class="na">class=</span><span class="s">&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;beans:property</span> <span class="na">name=</span><span class="s">&quot;dataSource&quot;</span> <span class="na">ref=</span><span class="s">&quot;dataSource&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/beans:bean&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>你肯定会问，这个“标准用户数据库表”的结构是什么样的。</p>

<p>默认的结构是有两张表：&#8221;users&#8221;和&#8221;authorities&#8221;。Users表有三个字段username，password，enabled。Authorities表有两个字段username，authority</p>

<p>如果你不满意标准的表结构，你还可以实现AuthenticationProvider接口自定义实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;authentication-manager&gt;</span>
</span><span class='line'>  <span class="nt">&lt;authentication-provider</span> <span class="na">ref=</span><span class="s">&#39;myAuthenticationProvider&#39;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/authentication-manager&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>添加Password编码器</h2>

<p>将密码以明文的方式存放在代码中或者是数据库中，始终是不安全的，AuthenticationProvider允许设置密码的加密编码。并且应该使用为此目的而设计的标准的安全hash算法，而不是一般的SHA或者MD5哈希算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&quot;bcryptEncoder&quot;</span> <span class="na">class=</span><span class="s">&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;authentication-manager&gt;</span>
</span><span class='line'>    <span class="nt">&lt;authentication-provider&gt;</span>
</span><span class='line'>        <span class="nt">&lt;password-encoder</span> <span class="na">ref=</span><span class="s">&quot;bcryptEncoder&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;user-service&gt;</span>
</span><span class='line'>            <span class="nt">&lt;user</span> <span class="na">name=</span><span class="s">&quot;jimi&quot;</span> <span class="na">password=</span><span class="s">&quot;d7e6351eaa13189a5a3641bab846c8e8c69ba39f&quot;</span>
</span><span class='line'>                  <span class="na">authorities=</span><span class="s">&quot;ROLE_USER, ROLE_ADMIN&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;user</span> <span class="na">name=</span><span class="s">&quot;bob&quot;</span> <span class="na">password=</span><span class="s">&quot;4e7421b1b8765d8f9406d87e7cc6aa784c4ab97f&quot;</span> <span class="na">authorities=</span><span class="s">&quot;ROLE_USER&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/user-service&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/authentication-provider&gt;</span>
</span><span class='line'><span class="nt">&lt;/authentication-manager&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Bcrypt是Spring文档里推荐的hash算法，它是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。（来自-百度百科）</p>

<h2>HTTPS</h2>

<p>很多情况下我们依旧需要采用以表单的方式来实现身份认真，就必须要避免，表单数据，即用户名和密码在HTTP协议下以明文传输。</p>

<p>Spring Security可以非常方面的支持要求某些URL必须是在https协议下才可以访问。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;http&gt;</span>
</span><span class='line'><span class="nt">&lt;intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/secure/**&quot;</span> <span class="na">access=</span><span class="s">&quot;ROLE_USER&quot;</span> <span class="na">requires-channel=</span><span class="s">&quot;https&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/**&quot;</span> <span class="na">access=</span><span class="s">&quot;ROLE_USER&quot;</span> <span class="na">requires-channel=</span><span class="s">&quot;any&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>...
</span><span class='line'><span class="nt">&lt;/http&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这段代码，当用户以http协议访问/secure/**，就会先跳转到https上。</p>

<p>参考资料：Spring Security Reference</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Web Security 实战 (二) - 自定义登录页面]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/14/spring-web-security-2/"/>
    <updated>2015-06-14T15:45:34+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/14/spring-web-security-2</id>
    <content type="html"><![CDATA[<p>上一章节结尾，我们实现了Spring web security的最小实现，拦截所有url，采用表单登录，用户名和密码采用inMemory方式保存。</p>

<p>你可能在想，这个登录页面从哪里来的，我们并没有直接去实现一个页面。事实上，正是因为我们没有设置登录页面，Spring Security就自动生成了一个，该页面是的Spring Security处理登录的标准页面。</p>

<p>不过，我们肯定是不会想要使用Spring Security给我们提供的标准页面，除非项目刚启动，处于demo阶段，否则，肯定采用自定义页面，那么如何做到呢？</p>

<p>在form-login标签提供了一个属性login-page，允许指定用户自定义的登录页面，于是，实现方式如下：</p>

<p>首先定义一个登录页面JSP文件，里面的form表单和标准页面一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="err">&lt;</span>%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;
</span><span class='line'><span class="err">&lt;</span>%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head&gt;</span>
</span><span class='line'>    <span class="nt">&lt;title&gt;</span>Spring MVC Security<span class="nt">&lt;/title&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;/spring-mvc-security/j_spring_security_check&quot;</span> <span class="na">method=</span><span class="s">&quot;POST&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;table&gt;</span>
</span><span class='line'>        <span class="nt">&lt;tbody&gt;</span>
</span><span class='line'>        <span class="nt">&lt;tr&gt;</span>
</span><span class='line'>            <span class="nt">&lt;td&gt;</span>User:<span class="nt">&lt;/td&gt;</span>
</span><span class='line'>            <span class="nt">&lt;td&gt;&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;j_username&quot;</span> <span class="na">value=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;&lt;/td&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/tr&gt;</span>
</span><span class='line'>        <span class="nt">&lt;tr&gt;</span>
</span><span class='line'>            <span class="nt">&lt;td&gt;</span>Password:<span class="nt">&lt;/td&gt;</span>
</span><span class='line'>            <span class="nt">&lt;td&gt;&lt;input</span> <span class="na">type=</span><span class="s">&quot;password&quot;</span> <span class="na">name=</span><span class="s">&quot;j_password&quot;</span><span class="nt">&gt;&lt;/td&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/tr&gt;</span>
</span><span class='line'>        <span class="nt">&lt;tr&gt;</span>
</span><span class='line'>            <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">&quot;2&quot;</span><span class="nt">&gt;&lt;input</span> <span class="na">name=</span><span class="s">&quot;submit&quot;</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="na">value=</span><span class="s">&quot;Login&quot;</span><span class="nt">&gt;&lt;/td&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/tr&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/tbody&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/table&gt;</span>
</span><span class='line'><span class="nt">&lt;/form&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后定义一个对应的RequestMapping：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Controller</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginController</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;/login&quot;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">GET</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">login</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;login&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后一步，就是配置http标签的内容，有两点，第一，设置form-login的属性login-page为登录页面的url，第二，设置login页面的访问权限为IS_AUTHENTICATED_ANONYMOUSLY，必须允许匿名用户可以访问，否则怎么登录呢。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;security:http&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/login&quot;</span> <span class="na">access=</span><span class="s">&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/**&quot;</span> <span class="na">access=</span><span class="s">&quot;ROLE_USER&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:form-login</span> <span class="na">login-page=</span><span class="s">&quot;/login&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;security:logout/&gt;</span>
</span><span class='line'><span class="nt">&lt;/security:http&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，你也可以这么写，3.1之后，允许多个http标签的定义。不过这么做，相当于完全绕过Spring Security的filterChain，不在Spring Security相关管理之下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;http</span> <span class="na">pattern=</span><span class="s">&quot;/css/**&quot;</span> <span class="na">security=</span><span class="s">&quot;none&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;http</span> <span class="na">pattern=</span><span class="s">&quot;/login&quot;</span> <span class="na">security=</span><span class="s">&quot;none&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>匿名登录</h2>

<p>你肯定会问，上面那样写和IS_AUTHENTICATED_ANONYMOUSLY有什么区别？这里参考：<a href="http://www.mossle.com/docs/auth/html/ch107-anonymous.html">http://www.mossle.com/docs/auth/html/ch107-anonymous.html</a></p>

<p>”匿名登录，即用户尚未登录系统，系统会为所有未登录的用户分配一个匿名用户，这个用户也拥有自己的权限，不过他是不能访问任何被保护资源的。</p>

<p>设置一个匿名用户的好处是，我们在进行权限判断时，可以保证SecurityContext中永远是存在着一个权限主体的，启用了匿名登录功能之后，我们所需要做的工作就是从SecurityContext中取出权限主体，然后对其拥有的权限进行校验，不需要每次去检验这个权限主体是否为空了。这样做的好处是我们永远认为请求的主体是拥有权限的，即便他没有登录，系统也会自动为他赋予未登录系统角色的权限，这样后面所有的安全组件都只需要在当前权限主体上进行处理，不用一次一次的判断当前权限主体是否存在。这就更容易保证系统中操作的一致性。“</p>

<p>这种一致性，统一了业务层代码的实现，将匿名用户看做是用户的一种类型，只是访问权限不一样而已。关于它们的优缺点 <a href="http://www.mossle.com/docs/auth/html/ch107-anonymous.html">http://www.mossle.com/docs/auth/html/ch107-anonymous.html</a> 的最后一部分有介绍。</p>

<p>设置登录后的跳转页面，form-login还提供了两个属性default-target-url和always-use-default-target。如果用户进入登录页面是因为要访问某个受限制的资源，当用户登录后，就会回到该访问资源，但是如果不是，default-target-url，就起到作用，指定了登录后的跳转页面，它的默认值是“/”。always-use-default-target的含义就很简单了，是否永远跳转，不管用户之前访问的资源。</p>

<h2>处理登出</h2>

<p>因为在xml配置中添加了security:logout，所以Spring Security也默认提供了一个登出URL：“/j_spring_security_logout”。</p>

<h2>获得用户名</h2>

<p>让Spring注入Principal即可</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Controller</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HomeController</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;/home&quot;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">GET</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">home</span><span class="o">(</span><span class="n">Principal</span> <span class="n">principal</span><span class="o">,</span> <span class="n">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">&quot;userName&quot;</span><span class="o">,</span> <span class="n">principal</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;home&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考资料： <br/>
1.Spring security reference</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Web Security 实战 (一) - 最少配置启动]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/12/spring-web-security-1/"/>
    <updated>2015-06-12T21:12:38+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/12/spring-web-security-1</id>
    <content type="html"><![CDATA[<p>你大概应该知道对于应用的安全性（无论是Web应用还是非Web应用），都包含两个方面“身份认证”（authentication）和“权限认证”（authorization，access-control）。身份认证是确立“访问者”所声称的“当事人”（principal）的一个过程（当事人可以是一个用户，设备，或者其他任何要在该应用操作的系统）。权限认证指的是确定该“当事人”是否可以在应用执行某一个操作的过程。</p>

<p>Spring Security能提供的功能亦围绕着这两个核心概念展开。</p>

<p>在“身份认证”方面，Spring Security能提供什么样的支持呢？如下：</p>

<p>HTTP BASIC authentication headers(an IETF RFC-based standard)   <br/>
HTTP Digest authentication headers(an IETF RFC-based standard)   <br/>
HTTPX.509 client certificate exchange(an IETF RFC-based standard)   <br/>
Form-based authentication(for simple user interface needs)   <br/>
&hellip;
更多类型，请参考Spring Security官文。</p>

<p>好吧，概念性的东西就介绍到这，本篇文章以实战为主，下面我们还是来聊聊大家更关心的实现：</p>

<p>在Spring Security 3.0中，相应的功能代码被分到了不同的Jar包中，以清晰的区分不同的功能和第三方依赖。下面介绍三个主要的Jar包：</p>

<p>Core - spring-security-core.jar</p>

<p>包含核心的“身份认证”和“访问控制”类和接口。任何Spring Security的应用都需要这个包，支持独立应用，远程客户端，方法级别（服务层）的安全，以及JDBC，主要包含下面几个顶级包：      <br/>
org.springframework.security.core  <br/>
org.springframework.security.access  <br/>
org.springframework.security.authentication    <br/>
org.springframework.security.provisioning</p>

<p>Web - spring-security-web.jar</p>

<p>包含对应的filter和web security相关的基础架构代码。任何与Servlet API相关的依赖。如果你需要Spring Security对web身份认证和URL级别的访问控制的支持，就需要它。里面主要包含的包是：org.springframework.security.web。</p>

<p>Config - spring-security-config.jar</p>

<p>包含security命名空间解析代码。如果你要使用XML方式的配置Security，那么你就会需要它。主要包含的包：org.springframework.security.config。</p>

<p>以web应用和xml配置为例，要开始使用Spring Security，需要至少下面的两个依赖，web和config，web会自动依赖于core，所以不用显示的指定core。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span> <span class="s1">&#39;org.springframework.security:spring-security-web:3.2.7.RELEASE&#39;</span>
</span><span class='line'>    <span class="n">compile</span> <span class="s1">&#39;org.springframework.security:spring-security-config:3.2.7.RELEASE&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了能够支持更多的Spring使用，我们以XML方法来配置Security框架。</p>

<p>下面介绍下在Security命名空间下，都有哪些重要的元素节点。</p>

<p>• Web/HTTP Security - 设置filter和相关的Service Bean，以应用框架的用户认证机制，安全化URL，渲染登录，错误页面等。</p>

<p>• Business Object(Method) Security - 用来保证业务层的安全。</p>

<p>• Authentication Manager - 处理身份认证请求</p>

<p>• Access Decision Manager - 为web和method提供访问决策。框架提供了一个默认实现，你也可以自定义一个，语法和普通Bean定义一样。</p>

<p>• AuthenticationProviders - 与Authentication Manager相对应的身份认真机制提供方，提供了多种标准选择，同样也支持自定义。</p>

<p>• UserDetailsService - 与authentication providers联系紧密，也会被其他Bean使用。</p>

<p>接下来，我们开始正式写代码。</p>

<p>首先，你需要在web.xml中定义一个名字是springSecurityFilterChain的filter。它提供了一个“钩子“，来启动Spring Security Web的基础架构。DelegatingFilterProxy是Spring框架中一个类，它代理着一个以Spring Bean方式定义在Spring上下文中的filter。在本例中，bean的名字是springSecurityFilterChain，它是Spring提供的内部基础架构Bean，所以，我们定义的一些自定义的Bean的时候，就不可以使用这个名字springSecurityFilterChain。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;filter&gt;</span>
</span><span class='line'>    <span class="nt">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="nt">&lt;/filter-name&gt;</span>
</span><span class='line'>    <span class="nt">&lt;filter-class&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="nt">&lt;/filter-class&gt;</span>
</span><span class='line'><span class="nt">&lt;/filter&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;filter-mapping&gt;</span>
</span><span class='line'>    <span class="nt">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="nt">&lt;/filter-name&gt;</span>
</span><span class='line'>    <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
</span><span class='line'><span class="nt">&lt;/filter-mapping&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>springSecurityFilterChain是由Spring框架定义。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">security</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">web</span><span class="o">.</span><span class="na">configuration</span><span class="o">;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSecurityConfiguration</span><span class="o">{</span>
</span><span class='line'>  <span class="nd">@org.springframework.context.annotation.Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;springSecurityFilterChain&quot;</span><span class="o">})</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">javax</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">Filter</span> <span class="nf">springSecurityFilterChain</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Exception</span> <span class="o">{</span> <span class="cm">/* compiled code */</span> <span class="o">}</span>   
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>做完上面的”钩子”配置，你就可以正式开始Spring上下文的定义。首先来配置Web/HTTP Security节点部分“http”：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;http</span> <span class="na">use-expressions=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;intercept-url</span> <span class="na">pattern=</span><span class="s">&quot;/**&quot;</span> <span class="na">access=</span><span class="s">&quot;hasRole(&#39;ROLE_USER&#39;)&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;form-login/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;logout/&gt;</span>
</span><span class='line'><span class="nt">&lt;/http&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是使得Spring Security工作的最小http节点配置。安全拦截所有应用中的URL，要求访问者（“当事人”）含有ROLE_USER权限，要求使用带有用户名和密码的表单登录，并提供一个登出的URL。上面的pattern可以使用正则表达式来匹配对应路径，access中的hasRole必须配合use-expressions=&ldquo;true&#8221;才能使用（4.0以上有所不同）。如果提供多种权限，ROLE_USER后面可以以逗号分隔以允许多种权限（如果是4.0以上版本，Spring会自动给hasRole中的值加上ROLE_作为前缀，所以需要注意）。</p>

<p>这里允许定义多个intercept-url以应对不同的url，比如，css，js的访问，自定义登陆页面的访问，等。由于该intercept-url会根据定义的先后顺序来解析输入的url，所以，越明确的url模式，越应该放在前面。</p>

<p>note：如果你对filter比较熟悉，你应该能明白intercept-url其实是在配置FilterChainProxy所使用的filter。</p>

<p>接下来，需要配置Authentication Manager：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;authentication-manager&gt;</span>
</span><span class='line'>    <span class="nt">&lt;authentication-provider&gt;</span>
</span><span class='line'>        <span class="nt">&lt;user-service&gt;</span>
</span><span class='line'>            <span class="nt">&lt;user</span> <span class="na">name=</span><span class="s">&quot;ben&quot;</span> <span class="na">password=</span><span class="s">&quot;ben&quot;</span> <span class="na">authorities=</span><span class="s">&quot;ROLE_USER&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/user-service&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/authentication-provider&gt;</span>
</span><span class='line'><span class="nt">&lt;/authentication-manager&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>authentication-provider和user-service分别创建了两个bean，DaoAuthenticationProvider和InMemoryDaoImpl。它们作为authentication-manager的子元素存在，而authentication-manager则创建了一个ProviderManager的Bean，并将authentication-provider注册到该ProviderManager。理解这段代码的含义很简单，一个用户ben，密码ben，拥有ROLE_USER这个权限。</p>

<p>你还可以通过user-service上的properties属性来指定一个properties文件作为用户定义的输入。</p>

<p>到此，你就完成了一个最简单的Spring Web Security的配置。拦截所有url，需要输入用户名和密码登录访问。</p>

<p>参考资料：   <br/>
1. Spring Security Reference。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Boot 深入浅出系列（二） - 用Gradle启动应用]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/11/spring-boot-starter-2/"/>
    <updated>2015-06-11T12:56:12+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/11/spring-boot-starter-2</id>
    <content type="html"><![CDATA[<p>在前面介绍的《用Spring Boot开发Spring项目 快速上手》上介绍过：</p>

<p>“通过Spring Boot创建的Java应用可以直接通过java -jar启动（即便它是Web应用）。也就是说，在这里，首先运行gradle assemble，得到jar文件，然后运行java -jar gs-spring-boot-0.1.0.jar。”</p>

<p>但是，我们肯定不能每次这样去启动SpringBoot的应用。好在是，官方提供了与构建相关的插件Spring Boot Gradle plugin，插件中提供了对应的task给你使用：</p>

<h2>Application tasks     </h2>

<p>bootRun - Run the project with support for auto-detecting main class and reloading static resources.  <br/>
distTar - Bundles the project as a JVM application with libs and OS specific scripts.  <br/>
distZip - Bundles the project as a JVM application with libs and OS specific scripts.  <br/>
installApp - Installs the project as a JVM application along with libs and OS specific scripts. <br/>
run - Runs this project as a JVM application.</p>

<h2>在构建中引入Spring Boot Gradle plugin</h2>

<p>首先，你需要在构建中加入该插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">buildscript</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">classpath</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-gradle-plugin:1.2.4.RELEASE&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;spring-boot&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>省略依赖的版本号</h2>

<p>SpringBoot插件会注册一个定制的依赖解析策略，允许你省略对依赖版本的配置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.thymeleaf:thymeleaf-spring4&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么问题来了，这个省略的版本号从哪里来呢？它有Spring Boot Plugin的版本号决定，比如，当前定义的插件是org.springframework.boot:spring-boot-gradle-plugin:1.2.4.RELEASE，版本号是1.2.4，那么对应的spring-boot-starter-web的版本号，也是1.2.4。</p>

<p>当然，如果你想显示的指定版本号也是可以的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.thymeleaf:thymeleaf-spring4:2.1.1.RELEASE&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>打包可执行的jar包或者war包</h2>

<p>一旦使用了Spring boot插件，它就会用bootRepackage任务改写archive的过程。</p>

<p>你可以在配置选项中指定main class，或者在Manifest添加Main-Class，如果你不指定，它会去搜索含有public static void main(String[] args)方法的类。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">bootRepackage</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">mainClass</span> <span class="o">=</span> <span class="s1">&#39;demo.Application&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想要打成War包，并部署到外部容器里面，除了要使用war插件，还需要将embedded container的依赖放在providedRuntime里。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;war&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">war</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">baseName</span> <span class="o">=</span> <span class="s1">&#39;myapp&#39;</span>
</span><span class='line'>    <span class="n">version</span> <span class="o">=</span>  <span class="s1">&#39;0.5.0&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">jcenter</span><span class="o">()</span>
</span><span class='line'>    <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s2">&quot;http://repo.spring.io/libs-snapshot&quot;</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">configurations</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">providedRuntime</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">providedRuntime</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-starter-tomcat&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考资料： <br/>
1.<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-gradle-plugin.html">http://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-gradle-plugin.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Boot 深入浅出系列（一） - 习惯使用注解]]></title>
    <link href="http://benweizhu.github.io/blog/2015/06/10/spring-boot-starter-1/"/>
    <updated>2015-06-10T22:19:19+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/06/10/spring-boot-starter-1</id>
    <content type="html"><![CDATA[<p>Spring Boot从一开始就告诉你，它更喜欢基于Java的配置，即注解的方式。所以它提供了你一大堆注解，并让你习惯使用注解。</p>

<p>@Bean</p>

<p>Indicates that a method produces a bean to be managed by the Spring container.</p>

<p>@Configuration</p>

<p>Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime</p>

<p>@EnableAutoConfiguration</p>

<p>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined.</p>

<p>@ComponentScan</p>

<p>Configures component scanning directives for use with @Configuration classes. Provides support parallel with Spring XML&rsquo;s &lt;context:component-scan> element.</p>

<h2>指定main application class的位置</h2>

<p>SpringBoot建议你将主应用class（main application class）放在包根路径上，即其他子包之上。@EnableAutoConfiguration通常放在你的main class上，这样也隐含的指定了对某些配置项的搜索路径。比如，对@Entity的搜索。</p>

<p>在主应用class上指定@ComponentScan，同样也隐式的指定了扫描时basePackage的路径。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@EnableAutoConfiguration</span>
</span><span class='line'><span class="nd">@ComponentScan</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">Application</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你的main application class的位置确实在包的根路径上，上面的三个注解，可以用@SpringBootApplication这一个注解代替。</p>

<h2>多种方式加载Bean</h2>

<p>你必然不会在main application class定义很多的@Bean，Spring提供两种方式将定义在另外一个带有@Configuration的类中的Bean加载，第一种，在Application类中使用@Import指定该类，第二种，让@ComponentScan扫描到该类。大部分情况都会选择第二种。</p>

<h2>加载XML的配置</h2>

<p>如果你必须使用XML的配置，你可以使用@ImportResource来加载指定的XML配置。</p>

<h2>Bean的自动配置</h2>

<p>SpringBoot有一个非常神秘的注解@EnableAutoConfiguration，官方的解释已经在上面的部分给出，简单点说就是它会根据定义在classpath下的类，自动的给你生成一些Bean，并加载到Spring的Context中。</p>

<p>它的神秘之处，不在于它能做什么，而在于它会生成什么样的Bean对于开发人员是不可预知（或者说不容易预知）。举个例子：</p>

<p>要开发一个基于Spring JPA的应用，会涉及到下面三个Bean的配置，DataSource，EntityManagerFactory，PlatformTransactionManager。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@EnableJpaRepositories</span>
</span><span class='line'><span class="nd">@EnableTransactionManagement</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationConfig</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Bean</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">DataSource</span> <span class="nf">dataSource</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Bean</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">EntityManagerFactory</span> <span class="nf">entityManagerFactory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="o">..</span>
</span><span class='line'>      <span class="n">factory</span><span class="o">.</span><span class="na">setDataSource</span><span class="o">(</span><span class="n">dataSource</span><span class="o">());</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">factory</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Bean</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">PlatformTransactionManager</span> <span class="nf">transactionManager</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">JpaTransactionManager</span> <span class="n">txManager</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">JpaTransactionManager</span><span class="o">();</span>
</span><span class='line'>      <span class="n">txManager</span><span class="o">.</span><span class="na">setEntityManagerFactory</span><span class="o">(</span><span class="n">entityManagerFactory</span><span class="o">());</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">txManager</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>@EnableJpaRepositories会查找满足作为Repository条件（继承父类或者使用注解）的类。</p>

<p>@EnableTransactionManagement的作用：Enables Spring&rsquo;s annotation-driven transaction management capability, similar to the support found in Spring&rsquo;s &lt;tx:*> XML namespace。</p>

<p>但是，如果你使用了@EnableAutoConfiguration，那么上面三个Bean，你都不需要配置。在classpath下面只引入了MySQL的驱动和SpringJpa。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">compile</span> <span class="err">&#39;</span><span class="nl">mysql:</span><span class="n">mysql</span><span class="o">-</span><span class="n">connector</span><span class="o">-</span><span class="nl">java:</span><span class="mf">5.1</span><span class="o">.</span><span class="mi">18</span><span class="err">&#39;</span>
</span><span class='line'><span class="n">compile</span> <span class="err">&#39;</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">jpa</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Application类中写下下面这段代码，可以查看SpringBoot给你生成了这些Bean：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ConfigurableApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">Application</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">Object</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&quot;dataSource&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Object</span> <span class="n">transactionManager</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&quot;transactionManager&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Object</span> <span class="n">entityManagerFactory</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&quot;entityManagerFactory&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entityManagerFactory</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">transactionManager</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="n">JpaTransactionManager</span><span class="o">)</span><span class="n">transactionManager</span><span class="o">).</span><span class="na">getDataSource</span><span class="o">());</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="n">JpaTransactionManager</span><span class="o">)</span><span class="n">transactionManager</span><span class="o">).</span><span class="na">getEntityManagerFactory</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">tomcat</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">pool</span><span class="o">.</span><span class="na">DataSource</span><span class="err">@</span><span class="mi">4</span><span class="n">f0e94db</span><span class="o">{</span><span class="n">ConnectionPool</span><span class="o">[</span><span class="n">defaultAutoCommit</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">defaultReadOnly</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">defaultTransactionIsolation</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span> <span class="n">defaultCatalog</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">driverClassName</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">mysql</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">Driver</span><span class="o">;</span> <span class="n">maxActive</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span> <span class="n">maxIdle</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span> <span class="n">minIdle</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span> <span class="n">initialSize</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span> <span class="n">maxWait</span><span class="o">=</span><span class="mi">30000</span><span class="o">;</span> <span class="n">testOnBorrow</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span> <span class="n">testOnReturn</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">timeBetweenEvictionRunsMillis</span><span class="o">=</span><span class="mi">5000</span><span class="o">;</span> <span class="n">numTestsPerEvictionRun</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">minEvictableIdleTimeMillis</span><span class="o">=</span><span class="mi">60000</span><span class="o">;</span> <span class="n">testWhileIdle</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">testOnConnect</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">password</span><span class="o">=********;</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">orm</span><span class="o">.</span><span class="na">jpa</span><span class="o">.</span><span class="na">LocalContainerEntityManagerFactoryBean</span><span class="err">@</span><span class="mi">5109</span><span class="n">d386</span>
</span><span class='line'>
</span><span class='line'><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">orm</span><span class="o">.</span><span class="na">jpa</span><span class="o">.</span><span class="na">JpaTransactionManager</span><span class="err">@</span><span class="mi">5</span><span class="n">c1e2bfa</span>
</span><span class='line'>
</span><span class='line'><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">tomcat</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">pool</span><span class="o">.</span><span class="na">DataSource</span><span class="err">@</span><span class="mi">4</span><span class="n">f0e94db</span><span class="o">{</span><span class="n">ConnectionPool</span><span class="o">[</span><span class="n">defaultAutoCommit</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">defaultReadOnly</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">defaultTransactionIsolation</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span> <span class="n">defaultCatalog</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="n">driverClassName</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">mysql</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">Driver</span><span class="o">;</span> <span class="n">maxActive</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span> <span class="n">maxIdle</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span> <span class="n">minIdle</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span> <span class="n">initialSize</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span> <span class="n">maxWait</span><span class="o">=</span><span class="mi">30000</span><span class="o">;</span> <span class="n">testOnBorrow</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span> <span class="n">testOnReturn</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">timeBetweenEvictionRunsMillis</span><span class="o">=</span><span class="mi">5000</span><span class="o">;</span> <span class="n">numTestsPerEvictionRun</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">minEvictableIdleTimeMillis</span><span class="o">=</span><span class="mi">60000</span><span class="o">;</span> <span class="n">testWhileIdle</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">testOnConnect</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span> <span class="n">password</span><span class="o">=********;...</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">orm</span><span class="o">.</span><span class="na">jpa</span><span class="o">.</span><span class="na">LocalContainerEntityManagerFactoryBean</span><span class="err">@</span><span class="mi">5109</span><span class="n">d386</span>
</span></code></pre></td></tr></table></div></figure>


<p>Bean中的URL，username和password是在属性文件中配置的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="err">#</span><span class="n">Database</span>
</span><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">url</span><span class="o">=</span><span class="nl">jdbc:mysql:</span><span class="c1">//localhost:3306/xxxx      </span>
</span><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">root</span>
</span><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">password</span><span class="o">=</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Disable自动配置</h2>

<p>如果你发现自动转配的Bean不是你想要的，你也可以disable它。比如说，我不想要自动装配Database的那些Bean</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@EnableAutoConfiguration</span><span class="o">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="o">{</span><span class="n">DataSourceAutoConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyConfiguration</span> <span class="o">{</span>
</span><span class='line'>  
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时，就会报下面的错了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Caused</span> <span class="nl">by:</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">beans</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">NoSuchBeanDefinitionException</span><span class="o">:</span> <span class="n">No</span> <span class="n">qualifying</span> <span class="n">bean</span> <span class="n">of</span> <span class="n">type</span> <span class="o">[</span><span class="n">javax</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">DataSource</span><span class="o">]</span> <span class="n">found</span> <span class="k">for</span> <span class="n">dependency</span>
</span></code></pre></td></tr></table></div></figure>


<p>习惯使用和正确使用上面这些注解，是正确使用Spring Boot的重要起步。</p>

<p>参考资料： <br/>
1.Spring Boot Reference <br/>
2.Spring JPA Reference</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当Entity继承遇到Hibernate的@PrePersist和@PreUpdate]]></title>
    <link href="http://benweizhu.github.io/blog/2015/05/30/issue-happened-when-entity-inheritance-meet-preinsert-and-preupdate/"/>
    <updated>2015-05-30T17:03:04+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/05/30/issue-happened-when-entity-inheritance-meet-preinsert-and-preupdate</id>
    <content type="html"><![CDATA[<p>上周做项目的时候遇到的关于实现审计日志方式的问题，这里记录一下。</p>

<p>假设你的数据库是这样设计的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;Customer&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;benwei&quot;</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nt">&quot;AdvancedCustomer&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;customerId&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;level&quot;</span><span class="p">:</span> <span class="mi">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个Customer表和一个AdvancedCustomer表，AdvancedCustomer表中含有CustomerId作为外键。</p>

<p>在Java中的Entity实现是这样的：AdvancedCustomer继承自Customer，父类定义的继承策略是Joind。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Entity</span>
</span><span class='line'><span class="nd">@Table</span>
</span><span class='line'><span class="nd">@Inheritance</span><span class="o">(</span><span class="n">Strategy</span><span class="o">=</span><span class="n">InheritanceType</span><span class="o">.</span><span class="na">JOINED</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
</span><span class='line'>  
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Entity</span>
</span><span class='line'><span class="nd">@Table</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdvancedCustomer</span> <span class="kd">extends</span> <span class="n">Customer</span> <span class="o">{</span>
</span><span class='line'>  
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Joind策略的含义是：A strategy in which fields that are specific to a subclass are mapped to a separate table than the fields that are common to the parent class, and a join is performed to instantiate the subclass.</p>

<p>通用的属性定义在父类中表，特殊的属性映射到另一个独立的表。</p>

<p>此时，你想要给应用添加一个审计功能。</p>

<p>你给Customer表添加LastModifiedBy和LastModifiedDate两个字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;Customer&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;benwei&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;lastModifiedBy&quot;</span><span class="p">:</span> <span class="s2">&quot;benwei&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;lastModifiedDate&quot;</span><span class="p">:</span> <span class="s2">&quot;21/6/2015 23:01:11&quot;</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nt">&quot;AdvancedCustomer&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;customerId&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;level&quot;</span><span class="p">:</span> <span class="mi">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>做法是使用EntityListener，在Listener中使用Hibernate的@PrePersist和@PreUpdate来监听事件的发生。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuditListener</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@PrePersist</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prePersist</span><span class="o">(</span><span class="n">Object</span> <span class="n">entity</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span><span class="o">(</span><span class="n">entity</span> <span class="n">instanceOf</span> <span class="n">AdvancedCustomer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="o">((</span><span class="n">AdvancedCustomer</span><span class="o">)</span><span class="n">entity</span><span class="o">).</span><span class="na">setLastModifiedDate</span><span class="o">(</span><span class="n">Datetime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>  
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@PreUpdate</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preUpdate</span><span class="o">(</span><span class="n">Object</span> <span class="n">entity</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Entity</span>
</span><span class='line'><span class="nd">@Table</span>
</span><span class='line'><span class="nd">@EntityListeners</span><span class="o">([</span><span class="n">AuditListener</span><span class="o">.</span><span class="na">class</span><span class="o">])</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdvancedCustomer</span> <span class="kd">extends</span> <span class="n">Customer</span> <span class="o">{</span>
</span><span class='line'>  
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>问题来了，这个prePersist或者preUpdate方法会在什么时候触发呢？当修改AdvancedCustomer中的任意变量时，比如name，level，都会触发prePersist或者preUpdate。</h3>

<p>但是，你到数据库中去查看审计事件变化时会发现，当创建一个新的Customer，或者更新Customer的名字字段都没有问题。</p>

<p>当update子类中的变量level的时候，lastModifiedDate并没有发生变化。这是为什么？</p>

<h3>要找到原因，必须打开showSql属性，来查看Hibernate到底产生的SQL语句是什么。</h3>

<p>你会发现，当修改level变量时，Hibernate只产生了一条update语句来更新AdvancedCustomer这张表。而创建Customer会同时更新AdvancedCustomer和Customer两张表，更新name字段，会更新Customer这张表。</p>

<p>也就是说，在PreUpdate触发之前，Hibernate在策略上已经决定了只更新AdvancedCustomer。即便之后改变了Customer中的lastModifiedDate，也没有改变它的行为。这里并不是说PreUpdate没有起到作用，而是Hibernate之决定更新一张表，至于更新什么内容，要等到PreUpdate之后决定（这一点可以从更新name时，lastModifiedDate发生了改变来证明）。</p>

<h2>如何解决：</h2>

<p>目前，我们没有完美的解决方案可以在仍然使用PreUpdate的情况下，保证审计信息更新正确。</p>

<p>出现这个问题的主要原因是因为我们的实现受到框架实现机制的限制。</p>

<p>所以，我们改变了实现的策略，既然受到框架本身实现策略的限制，我们就脱离框架，在还未计入框架管理范围之内，就将审计信息写入Entity内，那么可行的一种方式就是AOP。在触发Hibernate的save方法之前，将审计信息写入Entity。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在AngularJS环境下写单元测试：module，inject和$httpBackend]]></title>
    <link href="http://benweizhu.github.io/blog/2015/05/21/write-unit-test-in-angularjs/"/>
    <updated>2015-05-21T17:37:38+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/05/21/write-unit-test-in-angularjs</id>
    <content type="html"><![CDATA[<h2>Angular测试基础：module和inject</h2>

<p>先来最简单的样例代码，Controller端代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;angularGruntExampleApp&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s1">&#39;MainCtrl&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$scope</span><span class="p">.</span><span class="nx">awesomeThings</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>            <span class="s1">&#39;HTML5 Boilerplate&#39;</span><span class="p">,</span>
</span><span class='line'>            <span class="s1">&#39;AngularJS&#39;</span><span class="p">,</span>
</span><span class='line'>            <span class="s1">&#39;Karma&#39;</span>
</span><span class='line'>        <span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Controller: MainCtrl&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">beforeEach</span><span class="p">(</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;angularGruntExampleApp&#39;</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">MainCtrl</span><span class="p">,</span> <span class="nx">scope</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">beforeEach</span><span class="p">(</span><span class="nx">inject</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">$controller</span><span class="p">,</span> <span class="nx">$rootScope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">scope</span> <span class="o">=</span> <span class="nx">$rootScope</span><span class="p">.</span><span class="nx">$new</span><span class="p">();</span>
</span><span class='line'>        <span class="nx">MainCtrl</span> <span class="o">=</span> <span class="nx">$controller</span><span class="p">(</span><span class="s1">&#39;MainCtrl&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">$scope</span><span class="o">:</span> <span class="nx">scope</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">}));</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;should attach a list of awesomeThings to the scope&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">expect</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">awesomeThings</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>beforeEach()是Jasmine提供的全局方法，在每个测试方法执行之前，调用一次传入的回调函数。</p>

<p>module()方法是由angular-mocks提供，用来加载给定的Angular模块。</p>

<p>$rootScope.$new()创建了一个scope对象，并且在$controller获取MainCtrl时，将scope对象注入。</p>

<p>angular.mock.inject函数接受一个回调函数，回调函数的参数，是需要注入的外部依赖，可以是angular提供的服务，比如，这里的$controller和$rootScope，也可以是你想要测试的自定义服务，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Defined out reference variable outside</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">myService</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Wrap the parameter in underscores</span>
</span><span class='line'><span class="nx">beforeEach</span><span class="p">(</span><span class="nx">inject</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_myService_</span><span class="p">){</span>
</span><span class='line'>  <span class="nx">myService</span> <span class="o">=</span> <span class="nx">_myService_</span><span class="p">;</span>
</span><span class='line'><span class="p">}));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Use myService in a series of tests.</span>
</span><span class='line'><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;makes use of myService&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">myService</span><span class="p">.</span><span class="nx">doStuff</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，注入的<em>myService</em>，带有下划线，这是inject方法提供的一个特性，因为，我们总是希望在describe这个作用域下定义的变量名可以和真实的Service名字一致，所以inject允许你在注入的参数中加入下划线以区分注入的参数和定义的变量。</p>

<h2>$httpBackend</h2>

<p>在单元测试中，我们希望单元测试可以快速的运行，并且没有外部依赖，所以，我们不希望真正的发送HTTP请求到真正的服务器。我们想要的是验证请求已发送，然后将预先定义的请求返回。</p>

<p>$httpBackend就是这样一个提供fake响应的服务器端mock对象实现。通过$httpBackend.expect和$httpBackend.when来制定响应结果和条件。</p>

<p>Flushing HTTP requests</p>

<p>在产品环境中，代码中对http服务器端的请求都是异步，但是在单元测试中，我们不太容易实现异步的测试。httpBackend提供的flush方法允许测试立即flush等待的请求，这样就可以让异步请求同步化，这样就可以在单元测试中同步的测试http请求。</p>

<p>使用$httpBackend非常的简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$httpBackend</span> <span class="o">=</span> <span class="nx">$injector</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;$httpBackend&#39;</span><span class="p">);</span> <span class="c1">//注入$httpBackend服务</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$httpBackend</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;/customer/1&#39;</span><span class="p">).</span><span class="nx">respond</span><span class="p">({</span><span class="nx">customerId</span><span class="o">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="nx">name</span><span class="o">:</span><span class="s1">&#39;benwei&#39;</span><span class="p">});</span>
</span><span class='line'><span class="nx">scope</span><span class="p">.</span><span class="nx">getCustomer</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">);</span> <span class="c1">// 调用scope的方法发出http请求</span>
</span><span class='line'><span class="nx">$httpBackend</span><span class="p">.</span><span class="nx">flush</span><span class="p">();</span> <span class="c1">// 让http请求立刻执行</span>
</span><span class='line'>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">customer</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">({</span><span class="nx">customerId</span><span class="o">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="nx">name</span><span class="o">:</span><span class="s1">&#39;benwei&#39;</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考资料：  <br/>
1.<a href="http://docs.ngnice.com/api/ngMock">http://docs.ngnice.com/api/ngMock</a>  <br/>
1.<a href="http://docs.ngnice.com/api/ngMock/service/$httpBackend">http://docs.ngnice.com/api/ngMock/service/$httpBackend</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise/Q和AngularJS中的resolve]]></title>
    <link href="http://benweizhu.github.io/blog/2015/04/18/angularjs-resolve-and-promise-q/"/>
    <updated>2015-04-18T10:02:50+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/04/18/angularjs-resolve-and-promise-q</id>
    <content type="html"><![CDATA[<p>JavaScript是一种单线程的语言。这意味着运行一个有较长处理时间的代码A，会阻塞所有其他代码的执行，直到该代码A执行完。UI元素无响应，动画暂停，其他代码都不能运行。</p>

<p>解决这个问题的办法就是尽量避免同步执行。一种解决办法就是让这种需要较长处理时间的代码后执行。在JavaScript中，所有类似这样的操作都是通过回调函数实现。比如，JavaScript的事件处理器，当事件触发时，才被调用。</p>

<p>异步编程会让代码变得复杂难懂，许多JavaScript的API严重依赖于回调函数，这样就导致了回调的嵌套。比如，下面的ajax调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">ajax</span><span class="p">({</span>
</span><span class='line'>    <span class="nx">url</span><span class="o">:</span> <span class="nx">url1</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">ajax</span><span class="p">({</span>
</span><span class='line'>            <span class="nx">url</span><span class="o">:</span> <span class="nx">url2</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果上面的代码，再进行一次回调就更难以阅读了。</p>

<p>为了解决这个问题，许多JavaScript库（jQuery，AngularJS）提供了一个Promise对象来让异步编程模式同步化。看下面的一个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">myWebService</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&quot;http://www.example.com&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">myDb</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;data successfully saved&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;an error occurred while saving:&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>myWebService.get(&ldquo;<a href="http://www.example.com">http://www.example.com</a>&rdquo;)返回一个promise对象。该promise对象提供一个重要的方法then，并接受一个或者两个回调函数（success callback，failure callback）。</p>

<p>重点是，then方法调用之后，会再次返回一个promise对象，该promise对象是什么，取决于回调函数返回什么，还是什么都不返回。这样，你就可以将多层回调通过链接方式连接起来。这样就可以用同步化的方式来进行异步化编程。</p>

<p>在AngularJS中，通常使用$resource服务来进行restful的Ajax请求，所以对应需要success callback和failure callback。看下面的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">$resource</span><span class="p">(</span><span class="s1">&#39;/user/:userId&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">userId</span><span class="o">:</span><span class="s1">&#39;@id&#39;</span><span class="p">});</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">User</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">userId</span><span class="o">:</span><span class="mi">123</span><span class="p">},</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">user</span><span class="p">.</span><span class="nx">abc</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>Calling these methods invoke an $http with the specified http method, destination and parameters. When the data is returned from the server then the object is an instance of the resource class.</p>

<p>调用resource上的get方法，会触发一个$http请求，当请求数据从服务器端回来时，它是resource类的是一个实例。该实例有一个很重要的属性$promise，该属性返回给你对应的promise对象。于是上面那段通过回调方式编写的代码，就可以用同步的方式编写，如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">$resource</span><span class="p">(</span><span class="s1">&#39;/user/:userId&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">userId</span><span class="o">:</span><span class="s1">&#39;@id&#39;</span><span class="p">});</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">userPromise</span> <span class="o">=</span> <span class="nx">User</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">userId</span><span class="o">:</span><span class="mi">123</span><span class="p">}).</span><span class="nx">$promise</span><span class="p">;</span>
</span><span class='line'><span class="nx">userPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">user</span><span class="p">.</span><span class="nx">abc</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>理解这部分后，我们进行下一个话题：Angular的resolve。</p>

<p>在AngularJS路由进入一个页面时，对应的Controller可能会进行一些异步调用，比如，去服务器端获取一些需要在页面现实的数据。这种异步调用可能会花费较长的时间，这样就很可能导致页面抖动，页面在渲染完成后，现实数据还没有返回，甚至页面显示不正确。</p>

<p>为了解决这个问题，angular的路由提供了一个重要的属性resolve，允许在进入页面之前，进行一些必要的数据准备，然后将准备好的数据注入到Controller中，如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">templateUrl</span><span class="o">:</span> <span class="s1">&#39;views/main.html&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">controller</span><span class="o">:</span> <span class="s1">&#39;mainCtrl&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">resolve</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">user</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="s1">&#39;benweizhu&#39;</span><span class="p">};</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>resolve提供了一个重要的特性，如果返回的是一个promise对象，那么路由会等到这个promise对象resolve（成功或者失败的）后，再初始化Controller。这样，我们就可以在Controller初始化前，进行一些异步调用，比如resource的Ajax请求，这样就可以防止页面都会，或者渲染错误。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">templateUrl</span><span class="o">:</span> <span class="s1">&#39;views/main.html&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">controller</span><span class="o">:</span> <span class="s1">&#39;mainCtrl&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">resolve</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">user</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">User</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">userId</span><span class="o">:</span><span class="mi">123</span><span class="p">}).</span><span class="nx">$promise</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考资料：  <br/>
1.AngularJS官方网站 <br/>
2.<a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html">http://andyshora.com/promises-angularjs-explained-as-cartoon.html</a>   <br/>
3.<a href="https://thinkster.io/a-better-way-to-learn-angularjs/promises">https://thinkster.io/a-better-way-to-learn-angularjs/promises</a>   <br/>
4.<a href="https://msdn.microsoft.com/en-us/library/windows/apps/hh700330.aspx">https://msdn.microsoft.com/en-us/library/windows/apps/hh700330.aspx</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle深入与实战（六）Gradle的背后是什么？]]></title>
    <link href="http://benweizhu.github.io/blog/2015/03/31/deep-into-gradle-in-action-6/"/>
    <updated>2015-03-31T23:20:24+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/03/31/deep-into-gradle-in-action-6</id>
    <content type="html"><![CDATA[<h2>理解DSL（领域特定语言）</h2>

<p>DSLs come in two main forms: external and internal. An external DSL is a language that&rsquo;s parsed independently of the host general purpose language: good examples include regular expressions and CSS. External DSLs have a strong tradition in the Unix community. Internal DSLs are a particular form of API in a host general purpose language, often referred to as a fluent interface. &mdash;- Martin Fowler</p>

<p>Martin Fowler将DSL分为两类：外部DSL和内部DSL。外部DSL是一种独立的可解析的语言，举一个最常见的是例子，SQL，它专注于数据库的操作。内部DSL是通用语言所暴露的用来执行特定任务的API，它利用语言本身的特性，将API以特殊的形式（或者格式）暴露出来的。比如，Martin Fowler给出了关于流接口（fluent interface）。</p>

<p>总结一下，外部DSL是一种特定的独立语言，内部DSL是通用语言为实现特殊目的提供的API。</p>

<p>我们可以看下Martin Fowler提供的关于流接口的一个例子。流接口的实现方式同样是通用语言的写法，但相对于连续的调用set方法或者add方法，可读性方面要好很多。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeFluent</span><span class="o">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customer</span><span class="o">.</span><span class="na">newOrder</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="s">&quot;TAL&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">&quot;HPK&quot;</span><span class="o">).</span><span class="na">skippable</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&quot;LGV&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">priorityRush</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Gradle的DSL</h2>

<p>Gradle为了很好的描述构建，它提供了一套DSL，它是一种内部DSL。这套语言基于Groovy，但增加了一点点的特殊处理，以便在利用Groovy语言特性的之外，让它更像一个构建语言。</p>

<p>所以，Gradle的构建脚本和Groovy之间的关系是大于(>)。换句话说，如果你在Gradle的构建脚本中，写纯粹的Groovy代码是绝对没有问题的，这一点在官方文档的用户手册中也单独拿出一章来说明。</p>

<h2>构建脚本</h2>

<p>我们先暂且不去验证这一点，也不要着急着用Groovy去写一个功能强大且复杂的task，从构建脚本中跳出来，站在一个更高的位置来俯视Gradle。</p>

<p>在我们写Gradle脚本的时候，我们一般会写两种类型的，一种脚本，默认命名是build.gradle，另一种脚本，命名是settings.gradle。它们各自的作用，相信不用我在这里过多的介绍。在Gradle的世界里面，它们都叫做配置脚本。举个很简单的例子，在settings中配置，多项目结构有哪些模块，或者在build.gradle中，配置Java的sourceset。</p>

<p>那可能就有人问了，那在构建脚本中写一个task也算配置吗？我并没有配置什么东西，而是在用语言实实在在的写一系列的动作。这个算配置吗？</p>

<p>我想，这取决于对“配置”这个概念的理解。如果，我只是应用Java插件，写一个sourceset，或者写一个dependencies，这个配置就有点类似，传统意义上理解的“键值对”的配置。</p>

<p>如果涉及到写一个task的时候，我们就要把它想象成“对某一个对象的配置”，想象成一系列的set或者add操作（即便是sourceset，你也应该这么去理解，因为这才是本质）。</p>

<h2>基于Groovy的本质</h2>

<p>在前面介绍DSL概念的时候，我们了解到Gradle是一种内部DSL，是一系列的API，它基于Groovy。Groovy是什么？它是一种面向对象的编程语言，它的核心概念是对象。</p>

<p>Gradle基于Groovy但大于Groovy，它是经过“定制”的Groovy，是经过“定制”的面向对象语言，所以，由始至终，Gradle都离不开对象这个概念。</p>

<p>如果你明白了这个本质，那么就明白了写Gradle脚本，就和写Java代码是一个道理，写Gradle构建脚本就是写代码调用Gradle的API，只不过因为一些特性和特殊处理，让他看上去不太像一个标准的类C的编程语言（我更倾向于说类Java，因为C语言不是面向对象的），那么接下来，你所需要知道的就是Gradle提供的API长啥样。</p>

<h2>Gradle的对象</h2>

<p>既然我们知道了Gradle的本质是经过“定制”的<strong>面向对象</strong>语言（Groovy语言），那么我们就来看看Gradle里面有些什么对象。</p>

<p>如果你有读过Gradle的用户手册，那么，第六章，Build Script Basics，肯定是你必读的一章节，即便你当时看不太明白，只是依葫芦画瓢。现在你可以回过头来看下，该章节在一开始就进入主题，介绍了Gradle中两个的核心概念，project和task。</p>

<p>从组成关系上来看，我们知道，或者文档是这么说的，一个构建是由多个project组成，一个project是由多个task组成，task之间的依赖关系，构成了整个构建的流水线。</p>

<p>对于task的概念相对比较好理解，因为在命令行中，我们通过gradle build，进行Java的构建，这是一个看得见，摸得着的概念。</p>

<p>那project是什么？从你学习Gradle开始，到应用Java插件，实现Java的构建，好像从头到尾都没有直接接触过project这个概念，至少没有像task这样如此真实的接触。我们需要了解它吗？如果你只是依葫芦画瓢，参考Gradle的文档，进行构建的“配置”，那么你不用。</p>

<p>如果你想知道写的那些配置在本质上是什么？那么就有必要。</p>

<h2>Project对象和build.gradle</h2>

<p>为了不深究Gradle的实现原理（就是去读源代码），又要让大家觉得有据可依。我通过引用官方文档的一些描述来帮助大家理解Project对象。</p>

<p>For each project in the build, Gradle creates an object of type Project and associates this Project object with the build script. (Chapter 13. Writing Build Scripts)   <br/>
构建中的每一个project，Gradle都会创建一个Project对象，并将这个对象与构建脚本相关联。</p>

<p>There is a one-to-one relationship between a Project and a &ldquo;build.gradle&rdquo; file. (Interface Project API)   <br/>
Project对象与build.gradle是一对一的关系。</p>

<p>First, Gradle scripts are configuration scripts. As the script executes, it configures an object of a particular type. For example, as a build script executes, it configures an object of type Project. This object is called the delegate object of the script. (Gradle Build Language Reference)   <br/>
Gradle的脚本是配置脚本，当脚本执行时，它是在配置某一个特殊类型的对象。比如一个构建脚本的执行，它就是在配置一个Project类型的对象。这个对象叫做脚本的代理对象。</p>

<p>读完这三句话，应该可以清楚的明白build.gradle的本质，简单的说，build.gradle是对一个Project对象的配置。</p>

<h2>深入理解</h2>

<p>如果你还没明白，你可以仔细考量这三句话。因为这里，我们要进一步深入探讨上个部分引出的另一个概念：代理。</p>

<p>这个概念并不来自于Gradle，如果你熟悉Groovy，你肯定会立刻想到这是Groovy中很重要的一个概念。</p>

<p>在Groovy中，Object对象提供了一个重要的方法with，这个方法在JavaScript中也是存在的。with方法可以在一个闭包内辅助实现委托调用，在with的作用域内调用的任何方法，都被定向到该上下文对象上，这样就去掉了对该实例的多余引用，举个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="kt">def</span> <span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="kt">def</span> <span class="n">listWith</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="n">listWith</span><span class="o">.</span><span class="na">with</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">add</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span><span class='line'>  <span class="n">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">size</span><span class="o">())</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在with中，省去了对 list对象的引用。</p>

<p>而build.gradle和project对象，虽然从解析的角度不一定是通过with方式实现，但是它们之间就是这样的一个关系。</p>

<p>闭包内的内容就是build.gradle对project对象的操作。</p>

<p>这里我引用Gradle用户手册第十三章的内容来进一步说明，</p>

<p>Any method you call in your build script which is not defined in the build script, is delegated to the Project object.
Any property you access in your build script, which is not defined in the build script, is delegated to the Project object.（Chapter 13. Writing Build Scripts）</p>

<h2>通过现象看本质</h2>

<p>我们从理论上讲了这么多关于Gradle本质的东西，而且好像还有点道理，但我们还是要验证一下，透过现象来看本质。通过实践，进一步加强我们的理解。</p>

<h4>一个小小的task</h4>

<p>举个例子，我们在build.gradle中，写一个简单的task</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">task</span> <span class="n">helloWorld</span> <span class="o">&lt;&lt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span> <span class="s1">&#39;helloWorld&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你熟悉Groovy，并且知道它是针对project为上下文的一段代码，你会怎么看上面这段代码。是不是会有几个疑问？</p>

<p>问题一：是否有一个project的方法叫做task？答案：是，Project.task(String name)，返回一个Task对象。</p>

<p>问题二：helloWorld是一个参数吗？答案：是，它被解析为一个String类型的实参变量</p>

<p>问题三：符号“&lt;&lt;”是什么意思？答案：Groovy的强大特性，操作符重载。Task.leftShift(Closure action)，用来给task的action列表中添加一个action。</p>

<p>如果我用Groovy的写法，把它写成下面这样，是否就更好理解一些呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">task</span><span class="o">(</span><span class="s2">&quot;helloWorld&quot;</span><span class="o">).</span><span class="na">leftShift</span><span class="o">({</span>
</span><span class='line'>    <span class="n">println</span> <span class="s1">&#39;hello world&#39;</span>
</span><span class='line'><span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>当我们透过现象看到本质之后，你对Gradle的理解是不是不再是冷冰冰的闭包配置。是不是觉得Gradle其实没有那么神秘，不需要为Gradle中的奇怪的DSL感到困惑，它只是个API，读下API文档就好了。</p>

<p>最后总结，Gradle is Groovy but more than Groovy。</p>

<p>参考资料：</p>

<p>1.<a href="http://gradle.org/docs/current/userguide/writing_build_scripts.html">http://gradle.org/docs/current/userguide/writing_build_scripts.html</a>  <br/>
2.<a href="http://gradle.org/docs/current/javadoc/">http://gradle.org/docs/current/javadoc/</a>   <br/>
3.<a href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_delegation_strategy">http://docs.groovy-lang.org/latest/html/documentation/index.html#_delegation_strategy</a>   <br/>
4.Groovy程序设计</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA中的多对多关系]]></title>
    <link href="http://benweizhu.github.io/blog/2015/03/21/jpa-many-to-many-relationship/"/>
    <updated>2015-03-21T10:44:43+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/03/21/jpa-many-to-many-relationship</id>
    <content type="html"><![CDATA[<p>在关系型数据库中，表与表之间的关系是通过外键来实现，而其中最常见的关系有两种：一对多和多对多。</p>

<p>在面向对象的世界，对象与对象之间的关系是通过从源对象到目标对象的对象引用实现。关系是一个对象含有的其他对象或者对象的集合，而在关系型数据库中，关系要么通过定义另一张表的外键建立，要么通过中间表建立。</p>

<p>在Java或者JPA的世界里，所有的关系都是单向性的，一个源对象保有目标对象的索引，并不能保证目标对象和源对象一样包含源对象的索引。这个关系型数据库就不一样了，在关系型数据库中，表之间的关系通过外键来实现，查询语句通过这个外键，可以进行正向和反向的查询。</p>

<p>ManyToMany多对多关系是关系型数据库中一种非常常见的表关系。</p>

<p>在JPA中，如果要实现ManyToMany关系，常常是利用的一种方式是中间表。所有的ManyToMany关系都需要一个JoinTable，在这个JoinTable中，通过JoinColumns定义了两个外键，一个外键来指向源表的主键，另一个外键指向目标表的主键，通常JoinTable的主键是两个外键的组合。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Entity</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Id</span>
</span><span class='line'>  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ID&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="nd">@ManyToMany</span>
</span><span class='line'>  <span class="nd">@JoinTable</span><span class="o">(</span>
</span><span class='line'>      <span class="n">name</span><span class="o">=</span><span class="s">&quot;EMP_PROJ&quot;</span><span class="o">,</span>
</span><span class='line'>      <span class="n">joinColumns</span><span class="o">={</span><span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;EMP_ID&quot;</span><span class="o">,</span> <span class="n">referencedColumnName</span><span class="o">=</span><span class="s">&quot;ID&quot;</span><span class="o">)},</span>
</span><span class='line'>      <span class="n">inverseJoinColumns</span><span class="o">={</span><span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;PROJ_ID&quot;</span><span class="o">,</span> <span class="n">referencedColumnName</span><span class="o">=</span><span class="s">&quot;ID&quot;</span><span class="o">)})</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Project</span><span class="o">&gt;</span> <span class="n">projects</span><span class="o">;</span>
</span><span class='line'>  <span class="o">.....</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>双向ManyToMany</p>

<p>虽然在数据库中ManyToMany总是双向的，但是在对象模型中定义双向关系时，需要定义映射的发起方（管理方）和映射的接收方。发起方需要定义JoinTable，接收方则需要定义mappedBy。如果不使用mappedBy，则Jpa的实现者会认为，这种多对多关系是两个独立定义的关系，就会有重复的两行记录插入到JoinTable中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Entity</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Project</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Id</span>
</span><span class='line'>  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ID&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">&quot;projects&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employees</span><span class="o">;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>双向关系的共同毛病</p>

<p>需要应用程序自己去维护它们（对象）之间的双向关系，否则就不同步（out of sync）。在写set方法或者，多对多关系中的add方法时，需要注意将自己的引用设置到包含的集合对象中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">List</span> <span class="n">phones</span><span class="o">;</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addPhone</span><span class="o">(</span><span class="n">Phone</span> <span class="n">phone</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">phones</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">phone</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">phone</span><span class="o">.</span><span class="na">getOwner</span><span class="o">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">phone</span><span class="o">.</span><span class="na">setOwner</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Phone</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Employee</span> <span class="n">owner</span><span class="o">;</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setOwner</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">owner</span> <span class="o">=</span> <span class="n">employee</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">employee</span><span class="o">.</span><span class="na">getPhones</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">employee</span><span class="o">.</span><span class="na">getPhones</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>多对多关系的管理方的选择</p>

<p>多对多关系的管理方的定义取决于JoinTable的定义方，至于由哪一边作为管理方，取决于业务的关系，所以并不固定。但是必须要理解的时，它们之间建立关系的方式（即谁管理谁）。举个例子，User和Group，这是一个常见的多对多关系，当你将管理方定义在Group这边时，你要做的是将User添加到Group，然后保存Group。而不能将Group添加给User，然后保存User。</p>

<p>应用级联</p>

<p>由某一方来管理对象的操作，需要应用级联属性，来说明是否将级联操作传递到对应的实体类上。如果你在存储一个对象时，该对象关联到另一个对象，而它们之间的关系没有使用级联，则会抛出异常，告诉你，需要先存储关联对象。</p>

<p>级联操作的类型有6种，分别是ALL，PERSIST，MERGE，REMOVE，REFRESH，DETACH。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">enum</span> <span class="n">CascadeType</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** Cascade all operations */</span>
</span><span class='line'>    <span class="n">ALL</span><span class="o">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** Cascade persist operation */</span>
</span><span class='line'>    <span class="n">PERSIST</span><span class="o">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** Cascade merge operation */</span>
</span><span class='line'>    <span class="n">MERGE</span><span class="o">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** Cascade remove operation */</span>
</span><span class='line'>    <span class="n">REMOVE</span><span class="o">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** Cascade refresh operation */</span>
</span><span class='line'>    <span class="n">REFRESH</span><span class="o">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Cascade detach operation</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @since Java Persistence 2.0</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">DETACH</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="n">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考资料：  <br/>
1.<a href="http://en.wikibooks.org/wiki/Java_Persistence/ManyToMany">http://en.wikibooks.org/wiki/Java_Persistence/ManyToMany</a>   <br/>
2.<a href="http://stackoverflow.com/questions/4935095/jpa-hibernate-many-to-many-cascading">http://stackoverflow.com/questions/4935095/jpa-hibernate-many-to-many-cascading</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle深入与实战（五）自定义插件]]></title>
    <link href="http://benweizhu.github.io/blog/2015/03/15/deep-into-gradle-in-action-5/"/>
    <updated>2015-03-15T14:18:10+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/03/15/deep-into-gradle-in-action-5</id>
    <content type="html"><![CDATA[<p>利用Gradle做构建，必然逃不掉Gradle的插件的使用，即便是最简单的Java或Groovy的应用都需要使用Java插件或者Groovy插件。</p>

<p>Gradle插件的作用就是将会被重复利用的逻辑打包，这样就可以在不同的项目中重复的使用。比如在上一节中实现的集成测试任务，就可以打包到插件中，然后在其他的工程中使用，而不需要重复的写相同的任务。</p>

<p><strong>Gradle提供了三种写插件的方式：</strong></p>

<p>1.直接在build.gradle文件中写插件，然后直接使用，不好的地方很明显，不能在该build.gradle脚本之外的位置（其他脚本或者工程）中使用。</p>

<p>2.将插件写在项目的rootProjectDir/buildSrc/src/main/groovy包下，Gradle会负责编译和放置到classpath，虽然可以多个gradle脚本中使用，但是不能在其他工程中使用。</p>

<p>3.一个独立的插件工程，很明显，这是最常见的实现方式，因为可以被任何脚本或者工程使用。</p>

<p>为了节省时间，我们直接进入到最常见的实现方式：<strong>实现一个独立的插件工程</strong>。</p>

<h2>这是一个Groovy工程</h2>

<p>我们知道，Gradle项目是基于Groovy语言开发的，所以插件功能必然是一个Groovy工程，构建创建一个build.gradle文件。</p>

<figure class='code'><figcaption><span>build.gradle </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;idea&#39;</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;groovy&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span> <span class="nf">gradleApi</span><span class="o">()</span>
</span><span class='line'>    <span class="n">compile</span> <span class="nf">localGroovy</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">task</span> <span class="nf">wrapper</span><span class="o">(</span><span class="nl">type:</span> <span class="n">Wrapper</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">gradleVersion</span> <span class="o">=</span> <span class="s1">&#39;1.11&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>按照Groovy插件推荐的目录结构建立好下面结构的目录，你可以忽略java那一级</p>

<p>src/main/java     <br/>
src/main/resources   <br/>
src/main/groovy  <br/>
src/test/java   <br/>
src/test/resources        <br/>
src/test/groovy</p>

<h2>利用Plugin接口实现插件</h2>

<p>然后，我们写一个Groovy类，让它实现Plugin接口，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="kn">package</span> <span class="n">me</span><span class="o">.</span><span class="na">zeph</span><span class="o">.</span><span class="na">gradle</span><span class="o">.</span><span class="na">plugin</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">me.zeph.gradle.extension.HelloExtension</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.gradle.api.Plugin</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.gradle.api.Project</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">HelloPlugin</span> <span class="kd">implements</span> <span class="n">Plugin</span><span class="o">&lt;</span><span class="n">Project</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Project</span> <span class="n">project</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">project</span><span class="o">.</span><span class="na">task</span><span class="o">(</span><span class="s1">&#39;hello&#39;</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">println</span> <span class="s1">&#39;hello plugin&#39;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们通过project的task方法实现了一个名字是hello的task，里面打印了一句话。这个任务很简单，现在我们来增加一点点复杂度。记不记得大部分插件在使用之后，除了提供一些列的task，还提供了许多的closure（闭包），可以通过这些闭包传递一些参数进去。那么，这是怎么是实现的呢？很简单，利用project提供的扩展。</p>

<h2>扩展的使用</h2>

<p>定义一个名字是HelloExtension的Groovy类（名字其实无所谓叫什么，而且居然不需要实现任何的接口）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="kn">package</span> <span class="n">me</span><span class="o">.</span><span class="na">zeph</span><span class="o">.</span><span class="na">gradle</span><span class="o">.</span><span class="na">extension</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">HelloExtension</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">message</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>改变一些插件的实现：</p>

<figure class='code'><figcaption><span>build.gradle </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="kn">package</span> <span class="n">me</span><span class="o">.</span><span class="na">zeph</span><span class="o">.</span><span class="na">gradle</span><span class="o">.</span><span class="na">plugin</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">me.zeph.gradle.extension.HelloExtension</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.gradle.api.Plugin</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.gradle.api.Project</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">HelloPlugin</span> <span class="kd">implements</span> <span class="n">Plugin</span><span class="o">&lt;</span><span class="n">Project</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Project</span> <span class="n">project</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">project</span><span class="o">.</span><span class="na">extensions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s1">&#39;hello&#39;</span><span class="o">,</span> <span class="n">HelloExtension</span><span class="o">)</span>
</span><span class='line'>        <span class="n">project</span><span class="o">.</span><span class="na">task</span><span class="o">(</span><span class="s1">&#39;hello&#39;</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">println</span> <span class="n">project</span><span class="o">.</span><span class="na">hello</span><span class="o">.</span><span class="na">message</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>project.extensions.add(&lsquo;hello&rsquo;, HelloExtension)，这段代码将HelloExtension添加到project的extensions中，于是task就可以通过project.hello.message来获取。是不是很简单？</p>

<h2>告诉别人这是个插件：插件id</h2>

<p>那么，功能部分都写完了，怎么样让其他构件脚本知道这是一个插件能？配置META-INF。</p>

<p>在resources目录下建立这样一个目录结构：/resources/META-INF/gradle-plugins</p>

<p>然后在这里建立一个名字是me.zeph.hello.properties的Property文件，文件里的内容是：</p>

<figure class='code'><figcaption><span>me.zeph.hello.properties </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="na">implementation-class</span><span class="o">=</span><span class="s">me.zeph.gradle.plugin.HelloPlugin</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个Property文件的命名并不是随意定义的，名字的作用是定义该插件的id，什么意思？说白了就是apply时使用的名字。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;me.zeph.hello&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于里面的内容，我就不解释了，一眼就看明白了。</p>

<h2>使用生成的插件</h2>

<p>到这里，一个独立的插件工程就完成了，实验一把！！</p>

<p>运行gredlew clean assemble，将生成的jar文件，拷贝到其他的项目目录中（这里没有upload到仓库，所以直接文件形式引入依赖）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">buildscript</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">classpath</span> <span class="nf">fileTree</span><span class="o">(</span><span class="nl">dir:</span> <span class="s1">&#39;libs&#39;</span><span class="o">,</span> <span class="nl">include:</span> <span class="s1">&#39;*.jar&#39;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;me.zeph.hello&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">hello</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;hello gradle plugin&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后运行gradlew hello，就可以看到hello任务的执行。</p>

<p>总结，其实实现一个Gradle的独立插件工程，从建立工程的角度还是比较简单的，关键在如何通过Groovy实现插件，已经理解插件的api。</p>

<p>参考资料：</p>

<p>1.<a href="https://gradle.org/docs/current/userguide/custom_plugins.html">https://gradle.org/docs/current/userguide/custom_plugins.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Spring Boot开发Spring项目 快速上手]]></title>
    <link href="http://benweizhu.github.io/blog/2015/03/10/get-started-with-spring-boot-1-quick-start/"/>
    <updated>2015-03-10T16:44:18+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/03/10/get-started-with-spring-boot-1-quick-start</id>
    <content type="html"><![CDATA[<p>Spring Boot是Spring团队提供的全新框架，其设计目的是用来简化新的Spring应用的初始搭建以及开发过程。</p>

<p>Spring Boot的主要目的是：（参考：<a href="https://github.com/spring-projects/spring-boot%EF%BC%89">https://github.com/spring-projects/spring-boot%EF%BC%89</a></p>

<p>1.Provide a radically faster and widely accessible getting started experience for all Spring development  <br/>
2.Be opinionated out of the box, but get out of the way quickly as requirements start to diverge from the defaults  <br/>
3.Provide a range of non-functional features that are common to large classes of projects (e.g. embedded servers, security, metrics, health checks, externalized configuration)  <br/>
4.Absolutely no code generation and no requirement for XML configuration</p>

<p>快速启动Spring的开发，快速响应变化，提供非功能的特性，无需XML配置，这是Spring Boot所带来的优势。</p>

<p>下面通过一个例子，来快速的开发一个基于Spring Boot的Rest应用</p>

<figure class='code'><figcaption><span>build.gradle </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">buildscript</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">classpath</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;java&#39;</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;idea&#39;</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;spring-boot&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jar</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">baseName</span> <span class="o">=</span> <span class="s1">&#39;gs-spring-boot&#39;</span>
</span><span class='line'>    <span class="n">version</span> <span class="o">=</span>  <span class="s1">&#39;0.1.0&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">exclude</span> <span class="nl">module:</span> <span class="s2">&quot;spring-boot-starter-tomcat&quot;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">compile</span><span class="o">(</span><span class="s2">&quot;org.springframework.boot:spring-boot-starter-jetty&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">testCompile</span><span class="o">(</span><span class="s2">&quot;junit:junit&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">task</span> <span class="nf">wrapper</span><span class="o">(</span><span class="nl">type:</span> <span class="n">Wrapper</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">gradleVersion</span> <span class="o">=</span> <span class="s1">&#39;1.11&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Gradle中，应用了Spring Boot Gradle插件，你可以看到dependencies中并没有指定Spring Boot依赖的版本，这是因为已经在插件的定义中已经指定了版本：1.2.2.RELEASE，所以这里就可以省略。（关于省略版本这一点，在之后的文章中会解释）。</p>

<p>而且，依赖spring-boot-starter-web会一站式的帮你将与web开发相关的所有相关依赖下载，而不需要你一个个复制粘贴。这也是所有其他Spring Boot Starter的主要目的。</p>

<figure class='code'><figcaption><span>HelloController.java </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">me</span><span class="o">.</span><span class="na">zeph</span><span class="o">.</span><span class="na">controller</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@RestController</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;/&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;hello spring boot&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里定义了一个HelloController使用RestController注解，@RestController代表着@Controller和@ResponseBody，可以简化写Restful类型Controller的流程。</p>

<figure class='code'><figcaption><span>Application.java </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">me</span><span class="o">.</span><span class="na">zeph</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@SpringBootApplication</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">Application</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后一步，定义Spring boot应用的main方法，@SpringBootApplication等价于另外三个注解@Configuration，@EnableAutoConfiguration，@ComponentScan。</p>

<p>运行Gradle的命令: gradlew bootRun就可以启动应用程序。</p>

<p>通过Spring Boot创建的Java应用可以直接通过java -jar启动（即便它是Web应用）。也就是说，在这里，首先运行gradle assemble，得到jar文件，然后运行java -jar gs-spring-boot-0.1.0.jar。</p>

<p>参考资料： <br/>
1.<a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a> <br/>
2.<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[了解Spring Test对单元测试和集成测试的支持]]></title>
    <link href="http://benweizhu.github.io/blog/2015/02/07/spring-test-and-integration-test/"/>
    <updated>2015-02-07T23:20:45+08:00</updated>
    <id>http://benweizhu.github.io/blog/2015/02/07/spring-test-and-integration-test</id>
    <content type="html"><![CDATA[<p>在敏捷开发和测试驱动开发中，自动化测试一直被认为是让软件开发人员能够有信心的进行软件开发的力量源泉。</p>

<p>所以，软件开发人员不仅要关注写出高质量的产品代码，同时也要关注写出高质量的测试代码。</p>

<p>有些人说，对于开发人员，自动化测试不过是利用Junit，Mockito，Selenium等测试框架写出的另一段程序代码而已。虽然听起来很不爽，但我也不否认这一点，这是事实，但我们也是按照写产品代码的要求来写出高质量的测试代码。</p>

<p>回到正题，今天的主题是了解Spring对基于Spring开发的单元测试和集成测试的支持。</p>

<p>如果你正在使用Spring做开发，那么在写测试代码的时候，无论是单元测试还是集成测试，如果只是用到Junit，Mockito，EasyMock这些测试框架，你一定会发现，它们是不够的。Spring框架的优点就在于，它的策略是试图涵盖Java开发的所有部分，测试也不例外。Spring提供了一套API来支持基于Spring的单元测试和集成测试。下面，我们来看看Spring在测试方面都提供一些什么样的优秀特性。</p>

<h2>反射测试工具 org.springframework.test.util.ReflectionTestUtils</h2>

<p>依赖注入是Spring框架提供的最主要的特性之一，在Spring上下文管理范围内，Spring提供三种注入方式，Field注入，构造器注入，Setter注入。我们都知道在写单元测试时，只会关注被测试类本身的逻辑，一般我们都会将类中的依赖进行mock。</p>

<p>在没有Spring提供的反射测试工具的时候，我们一般都倾向于构造器注入，Setter注入的方式，因为这样在写测试代码时候，可以将mock的依赖传入到被测试类。但实际上，在Field上注入更符合Spring风格，或者更容易理解，我需要Spring给我注入这个对象，我就在它上面加一个@Autowired注解。所以构造器注入和Setter注入多少都是为了方便测试，不得已而为之。更有甚者，其实采用的是Field注入，但是为了测试，不得以添加一个setter方法。这就违反了简洁代码的原则，无用的方法，或者只被测试用到方法。</p>

<p>还好，Spring提供的ReflectionTestUtils拯救了我们。它提供这样的一个方法，ReflectionTestUtils.setField()，通过反射的方式将想要的依赖设置到对应的field上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@param</span> <span class="n">target</span> <span class="n">the</span> <span class="n">target</span> <span class="n">object</span> <span class="n">on</span> <span class="n">which</span> <span class="n">to</span> <span class="n">set</span> <span class="n">the</span> <span class="n">field</span>
</span><span class='line'><span class="nd">@param</span> <span class="n">name</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">field</span> <span class="n">to</span> <span class="n">set</span>
</span><span class='line'><span class="nd">@param</span> <span class="n">value</span> <span class="n">the</span> <span class="n">value</span> <span class="n">to</span> <span class="n">set</span>
</span><span class='line'>
</span><span class='line'><span class="n">ReflectionTestUtils</span><span class="o">.</span><span class="na">setField</span><span class="o">(</span><span class="n">xxService</span><span class="o">,</span> <span class="s">&quot;xxDao&quot;</span><span class="o">,</span> <span class="n">mockedXxDao</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Spring MVC测试的Mock对象：MockHttpServletRequest，MockHttpSession等。</h2>

<p>如果你正在测试Controller，而Controller又恰好对HttpServletRequest和HttpSession有操作，那么Spring提供的MockHttpServletRequest，MockHttpSession就派上用场了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MockHttpServletRequest</span> <span class="n">mockHttpServletRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MockHttpServletRequest</span><span class="o">();</span>
</span><span class='line'><span class="n">MockHttpSession</span> <span class="n">mockHttpSession</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MockHttpSession</span><span class="o">();</span>
</span><span class='line'><span class="n">mockHttpSession</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&quot;username&quot;</span><span class="o">,</span> <span class="s">&quot;user&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">mockHttpServletRequest</span><span class="o">.</span><span class="na">setSession</span><span class="o">(</span><span class="n">mockHttpSession</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，针对上面这种做法，你采用mockito也是可以实现的，而且代码量也差不多。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">HttpServletRequest</span> <span class="n">mockHttpServletRequest</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">HttpServletRequest</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="n">HttpSession</span> <span class="n">mockHttpSession</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">HttpSession</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="n">when</span><span class="o">(</span><span class="n">mockHttpSession</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;username&quot;</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">when</span><span class="o">(</span><span class="n">mockHttpServletRequest</span><span class="o">.</span><span class="na">getSession</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">mockHttpSession</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，如果你的Controller类中，使用了某个静态工具类方法，它对HttpServletRequest和HttpSession做了各种各样的操作，来维护当前用户的某些状态。从本质上，你应该将静态方法mock，但这并不容易实现。于是，你就必须mock HttpServletRequest和HttpSession中各种各样的依赖，来保证静态工具类方法不会抛空指针，而其中这些会抛空指针的操作与你期待的测试的行为无关。最直接的结果就是测试中的mock逻辑会特别的多，关键还不一定正确。</p>

<p>Spring的MockHttpServletRequest和MockHttpSession就可以解决这类问题，它默认初始化好大部分HttpServletRequest和HttpSession需要的依赖，所以不会出现空指针问题，也就简化了mock的过程，而其他你期待的返回结果都可以通过setter配置进去。</p>

<h2>Spring在集成测试方面的支持</h2>

<h3>SpringJUnit4ClassRunner，@ContextConfiguration，@WebAppConfiguration，MockMvc</h3>

<p>SpringJUnit4ClassRunner：它是在Junit下启动Spring集成测试的基础，为Junit提供Spring TestContext Framework所拥有的功能。 <br/>
@ContextConfiguration：用来决定根据什么样的配置为集成测试加载和配置ApplicationContext。 <br/>
@WebAppConfiguration：用来声明集成测试加载的ApplicationContext应该是一个WebApplicationContext。  <br/>
MockMvc：是Spring在服务器端对Spring MVC测试的支持，可以在对Controller的集成测试中，模拟对Controller某个Request的调用，是非常实用的集成测试组件。</p>

<p>看下面一个例子，如何使用上面4个组件来实现Controller的集成测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">...</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@ContextConfiguration</span><span class="o">(</span><span class="n">classes</span> <span class="o">=</span> <span class="n">WebContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@WebAppConfiguration</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">xxxIntegrationTest</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="n">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Autowired</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">WebApplicationContext</span> <span class="n">webApplicationContext</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Before</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">mockMvc</span> <span class="o">=</span> <span class="n">MockMvcBuilders</span><span class="o">.</span><span class="na">webAppContextSetup</span><span class="o">(</span><span class="n">webApplicationContext</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Test</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldReturnKits</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">&quot;/form&quot;</span><span class="o">))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
</span><span class='line'>          <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">().</span><span class="na">mimeType</span><span class="o">(</span><span class="s">&quot;text/html&quot;</span><span class="o">))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">forwardedUrl</span><span class="o">(</span><span class="s">&quot;/WEB-INF/layouts/main.jsp&quot;</span><span class="o">));</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>测试类的事务管理 @TransactionConfiguration，@Transactional，@BeforeTransaction，@AfterTransaction</h3>

<p>如果你正在对Dao层或者说数据库做集成测试，包括了CRUD所有基本操作的测试，那么你肯定会希望在单个测试运行结束之后，可以将数据库的状态回滚，这样除了可以重复的运行测试，更重要的是不会影响到其他测试，不会弄脏数据。那么，Spring提供的事务管理功能，除了可以实现产品代码中的事务管理，还可以实现测试代码的事务管理。</p>

<p>@TransactionConfiguration是为集成测试提供的类似@EnableTransactionManagement的功能的注解，用来显示的为集成测试指定某个TransactionManager和Rollback策略。但它并不是必须的，如果在Spring的上下文中，只有一个TransactionManager，且bean的名字是transactionManager，并且你认为的默认策略是Rollback，那么就可以不必配置@TransactionConfiguration。</p>

<p>@Transactional就和产品代码中一样，你需要某个测试类具有事务功能，就在该测试类上加上@Transactional注解。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">...</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@TransactionConfiguration</span><span class="o">(</span><span class="n">transactionManager</span> <span class="o">=</span> <span class="s">&quot;txManager&quot;</span><span class="o">)</span>
</span><span class='line'><span class="nd">@Transactional</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">xxxDaoIntegrationTest</span> <span class="o">{</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>@BeforeTransaction，@AfterTransaction，顾名思义，就是在事务前和事务后做的对应操作。</p>

<h3>@TestPropertySource，@DirtiesContext</h3>

<p>@PropertySource用来以声明式的方式将Properties加载到Spring的Environment变量中，@TestPropertySource拥有比@PropertySource更高的优先级，可以用来加载专门为测试提供的Properties。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@PropertySource</span><span class="o">(</span><span class="s">&quot;classpath:/com/myco/app.properties&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
</span><span class='line'>     <span class="nd">@Autowired</span>
</span><span class='line'>     <span class="n">Environment</span> <span class="n">env</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>     <span class="nd">@Bean</span>
</span><span class='line'>     <span class="kd">public</span> <span class="n">TestBean</span> <span class="nf">testBean</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>         <span class="n">TestBean</span> <span class="n">testBean</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TestBean</span><span class="o">();</span>
</span><span class='line'>         <span class="n">testBean</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;testbean.name&quot;</span><span class="o">));</span>
</span><span class='line'>         <span class="k">return</span> <span class="n">testBean</span><span class="o">;</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@ContextConfiguration</span>
</span><span class='line'><span class="nd">@TestPropertySource</span><span class="o">(</span><span class="s">&quot;/test.properties&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyIntegrationTests</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// class body...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>@DirtiesContext用来说明在某个测试执行之后，会导致Spring Context被污染，比如，修改了某个执行策略，改变了某个单例对象的状态。此时，该Context应该被关闭，之后的测试会使用新的Context。</p>

<p>@DirtiesContext可以被用在测试类上，也可以用在测试方法上，具体行为如下：   <br/>
* after the current test, when declared at the method level   <br/>
* after each test method in the current test class, when declared at the class level with class mode set to AFTER_EACH_TEST_METHOD   <br/>
* after the current test class, when declared at the class level with class mode set to AFTER_CLASS</p>

<p>这里只是介绍一些常用的比较重要的特性，除了以上这些，Spring Test Framework还提供许多其他特性，有效利用它们，可以让你写出方便的进行基于Spring的应用的测试，同时也是保证写出高质量测试的基础。</p>

<p>参考资料：  <br/>
1.Spring Reference Document, Spring Test</p>
]]></content>
  </entry>
  
</feed>
